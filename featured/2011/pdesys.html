<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Specifying large systems of PDEs with ease &mdash; FEniCS Project</title>
    
    <link rel="stylesheet" href="../../_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.9.9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="FEniCS Project" href="../../index.html" />
    <link rel="up" title="Featured articles of the FEniCS project" href="../index.html" />
    <link rel="next" title="Release notes for FEniCS" href="../../releases/index.html" />
    <link rel="prev" title="FEniCS 1.0-beta" href="fenics_1beta.html" />



<link rel="shortcut icon" href="../../_static/fenics.ico" />


<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-19595948-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </head>
  <body>
<div class="wrapper">
  <a href="/"><img src="../../_static/fenics_banner.png" width="900px" alt="FEniCS Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
	<li class="page_item"><a href="/about/" title="Find out more about the FEniCS project">About</a></li>
	<li class="page_item"><a href="/download/" title="Obtain the FEniCS project">Download</a></li>
	<li class="page_item"><a href="/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
	<li class="page_item"><a href="/applications/" title="Learn how others are using the FEniCS project">Applications</a></li>
	<li class="page_item"><a href="/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
	<li class="page_item"><a href="/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
	<li class="page_item"><a href="/support/" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="specifying-large-systems-of-pdes-with-ease">
<h1>Specifying large systems of PDEs with ease<a class="headerlink" href="#specifying-large-systems-of-pdes-with-ease" title="Permalink to this headline">¶</a></h1>
<div class="line-block">
<div class="line">Featured article 2011-08-19</div>
</div>
<div class="line-block">
<div class="line"><em>Created by Mikael Mortensen and Hans Petter Langtangen</em></div>
</div>
<p>This article describes the <a class="reference external" href="https://launchpad.net/cbcpdesys">CBC.PDESys</a>
Python package, built on top of FEniCS, for specifying and solving large
systems of nonlinear PDEs with very compact and flexible code.</p>
<div class="section" id="about-solving-large-systems-of-nonlinear-pdes">
<h2>About solving large systems of nonlinear PDEs<a class="headerlink" href="#about-solving-large-systems-of-nonlinear-pdes" title="Permalink to this headline">¶</a></h2>
<div class="figure align-right">
<a class="reference internal image-reference" href="../../_images/dolfin.gif"><img alt="../../_images/dolfin.gif" src="../../_images/dolfin.gif" style="width: 360px;" /></a>
</div>
<p>Computational Fluid Dynamics (CFD) presents many tough challenges for
a scientific computing software. The Navier-Stokes equations that are used to
model Newtonian fluid flows are represented by a nonlinear
system of PDEs, where velocity is non trivially coupled with pressure &#8211;
and that is just the beginning. The fluid may also interact with solid objects,
flames, particles or simply another fluid with a different density.
Most applications we investigate today are built by adding more and
more PDE systems on top of the basic fluid flow model. For example,
to study combustion we need to couple the Navier-Stokes equations with
a turbulence model and several (often more than 10) nonlinear scalar
transport equations, one for each of the reacting species. Combustion
is hot, so we have to incorporate the energy equation in the model
system of PDEs as well.
Each of the three components (Navier-Stokes, turbulence model and
combustion) of the complete model problem is represented by its own system
of PDEs.</p>
<p>In fact, the needs of CFD is simply a very flexible software
environment for systems of nonlinear PDEs. To meet these needs, we
created the completely general
CBC.PDESys Python package on top of FEniCS.  The purpose of the
package is to offer the computational scientist an efficient way of</p>
<blockquote>
<div><ul class="simple">
<li>specifying possibly large, complicated systems of PDEs,</li>
<li>dividing each system of PDEs into subsystems that are solved
either fully coupled or segregated,</li>
<li>linearizing nonlinear PDEs in a flexible way (Picard or Newton strategies),</li>
</ul>
</div></blockquote>
<p>The package targets any system of PDEs, but the applications so
far have been restricted to CFD. The stream-functions above illustrating
flow past a dolphin are computed in the tutorial given below.</p>
</div>
<div class="section" id="proof-of-concept-the-elliptic-relaxation-model">
<h2>Proof of concept &#8211; The elliptic relaxation model<a class="headerlink" href="#proof-of-concept-the-elliptic-relaxation-model" title="Permalink to this headline">¶</a></h2>
<p>Reynolds Averaged Navier-Stokes (RANS) models are widely used in
industry for modeling statistical properties of turbulent flows. One
of the most advanced RANS models around is the elliptic relaxation
model. This model consists of the RANS equations and two coupled
second rank tensor equations for modeling the Reynolds stress
(<span class="math">\(\overline{u'_i u'_j}\)</span>). The model is often discussed in textbooks on
advanced modeling of turbulent flows, but is rarely in use because of its
complexity and because it is not implemented in any commercial
CFD software.  Without going too much into detail the most important
equations of the model look something like</p>
<div class="math">
\[\begin{split}     \frac{\partial \overline{u_i}} {\partial t} + \overline{u_j} \frac{\partial \overline{u_i}}{\partial x_j}
      &amp;= - \frac{1} {\varrho}\frac{\partial p}{\partial x_i} + \frac{\partial}{\partial x_j} \nu( \frac{\partial \overline{u_i}}{\partial x_j} + \frac{\partial \overline{u_j}}{\partial x_i})
            - \frac{\partial \overline{u'_i u'_j}}{\partial x_j} + \overline{f_i}, \\
   \frac{\partial \overline{u_i}}{\partial x_i} &amp;= 0, \\
 \frac{\partial \overline{u'_i u'_j}} {\partial t} + \overline{u_k} \frac{\partial \overline{u'_i u'_j}}{\partial x_k} +
\frac{\partial T_{kij}}{\partial x_k}  &amp;= {\mathbb{P}}_{ij} + {\mathbb{G}}_{ij} - \varepsilon_{ij}, \\
 L^2 \nabla^2 f_{ij} - f_{ij} &amp;=  -\frac{{\mathbb{C}}_{ij}}{k} - \frac{\overline{u'_i u'_j}/k - 2\delta_{ij}/{3}}{T}, \\
 {\mathbb{P}}_{ij} &amp;= -\overline{u'_i u'_k} \frac{\partial \overline{u_j}}{\partial x_k} - \overline{u'_j u'_k} \frac{\partial \overline{u_i}}{\partial x_k}, \\
\varepsilon_{ij} &amp;= 2\nu\overline{\frac{\partial u_i}{\partial x_k} \frac{\partial u_j}{\partial x_k}}, \\
 {\mathbb{G}}_{ij} &amp;= \left(\varepsilon_{ij} - \frac{\overline{u'_i u'_j}}{k} \varepsilon \right) + k f_{ij}, \\
... &amp;=\end{split}\]</div>
<p>Here <span class="math">\(\overline{u_i}\)</span> is a component of the Reynolds averaged
velocity. The first two equations are basically the incompressible
Navier-Stokes equations for <span class="math">\(\overline{u_i}\)</span> (with variable viscosity),
while the rest of the equations define the turbulence model.
Note that we have two PDEs for the two second rank tensors
<span class="math">\(\overline{u'_i u'_j}\)</span> and <span class="math">\(f_{ij}\)</span>.  All in all the model requires
solving for
two second rank PDEs, one vector PDE and 3 scalar PDEs plus a number
of derived quantities. That is, we need to solve 18 coupled, highly
nonlinear PDEs.</p>
<p>FEniCS has support for working with PDEs of second rank tensors and as
such we have been able to implement the elliptic relaxation model
using no more than 300 lines of code. The variational form for the two
coupled second rank tensors looks like</p>
<div class="highlight-py"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Steady_RijFij_1</span><span class="p">(</span><span class="n">RIJFIJBase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Rij</span><span class="p">,</span> <span class="n">Rij_</span><span class="p">,</span> <span class="n">v_Rij</span><span class="p">,</span> <span class="n">k_</span><span class="p">,</span> <span class="n">e_</span><span class="p">,</span> <span class="n">Pij_</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">u_</span><span class="p">,</span> <span class="n">nut_</span><span class="p">,</span>
             <span class="n">Fij</span><span class="p">,</span> <span class="n">Fij_</span><span class="p">,</span> <span class="n">v_Fij</span><span class="p">,</span> <span class="n">Aij_</span><span class="p">,</span> <span class="n">Aij</span><span class="p">,</span> <span class="n">PHIij_</span><span class="p">,</span> <span class="n">Cmu</span><span class="p">,</span> <span class="n">T_</span><span class="p">,</span> <span class="n">L_</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">Fr</span> <span class="o">=</span> <span class="n">nu</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">Rij</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v_Rij</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> \
             <span class="o">+</span> <span class="n">inner</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">Rij</span><span class="p">),</span> <span class="n">u_</span><span class="p">)</span> <span class="p">,</span> <span class="n">v_Rij</span> <span class="p">)</span><span class="o">*</span><span class="n">dx</span> \
             <span class="o">-</span> <span class="n">inner</span><span class="p">(</span> <span class="n">k_</span><span class="o">*</span><span class="n">Fij</span> <span class="p">,</span> <span class="n">v_Rij</span> <span class="p">)</span><span class="o">*</span><span class="n">dx</span> \
             <span class="o">-</span> <span class="n">inner</span><span class="p">(</span> <span class="n">Pij_</span> <span class="p">,</span> <span class="n">v_Rij</span> <span class="p">)</span><span class="o">*</span><span class="n">dx</span> \
             <span class="o">+</span> <span class="n">inner</span><span class="p">(</span> <span class="n">Rij</span><span class="o">*</span><span class="n">e_</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">k_</span><span class="p">)</span> <span class="p">,</span> <span class="n">v_Rij</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> \
             <span class="o">+</span> <span class="n">inner</span><span class="p">(</span> <span class="n">Cmu</span><span class="o">*</span><span class="n">T_</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">Rij</span><span class="p">),</span> <span class="n">Rij_</span><span class="p">)</span> <span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">v_Rij</span><span class="p">)</span> <span class="p">)</span><span class="o">*</span><span class="n">dx</span>

        <span class="n">Ff</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span> <span class="n">grad</span><span class="p">(</span><span class="n">Fij</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">L_</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">v_Fij</span><span class="p">)</span> <span class="p">)</span><span class="o">*</span><span class="n">dx</span> \
             <span class="o">+</span> <span class="n">inner</span><span class="p">(</span> <span class="n">Fij</span> <span class="p">,</span> <span class="n">v_Fij</span> <span class="p">)</span><span class="o">*</span><span class="n">dx</span> \
             <span class="o">-</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">k_</span><span class="p">)</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span> <span class="n">PHIij_</span> <span class="p">,</span> <span class="n">v_Fij</span> <span class="p">)</span><span class="o">*</span><span class="n">dx</span> \
             <span class="o">-</span> <span class="p">(</span><span class="mf">2.</span><span class="o">/</span><span class="n">T_</span><span class="p">)</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span> <span class="n">Aij_</span> <span class="p">,</span> <span class="n">v_Fij</span> <span class="p">)</span><span class="o">*</span><span class="n">dx</span>

        <span class="k">return</span> <span class="n">Fr</span> <span class="o">+</span> <span class="n">Ff</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">Rij</span></tt>, <tt class="docutils literal"><span class="pre">Fij</span></tt>, <tt class="docutils literal"><span class="pre">v_Rij</span></tt>, and <tt class="docutils literal"><span class="pre">v_Fij</span></tt> are the trial- and test
functions for <span class="math">\(R_{ij}\equiv \overline{u'_i u'_j}\)</span> and <span class="math">\(f_{ij}\)</span>,
respectively. The most recently computed approximations to <tt class="docutils literal"><span class="pre">Rij</span></tt> and
<tt class="docutils literal"><span class="pre">Fij</span></tt> are recognized by an underscore: <tt class="docutils literal"><span class="pre">Rij_</span></tt> and <tt class="docutils literal"><span class="pre">Fij_</span></tt>. More details
of the implementation and some results for turbulent flow in an axial
diffusor is provided in <a class="reference external" href="http://bazaar.launchpad.net/~cbc.rans/cbc.rans/mikael/view/head:/doc/overview/cbc.rans-MekIT11.pdf">cbc.rans-MekIT11.pdf</a>. The contours of
<span class="math">\(f_{12}\)</span> (left) and <span class="math">\(\overline{u'_1 u'_2}\)</span> (right) in the diffusior
are shown below:</p>
<div class="figure align-left">
<a class="reference internal image-reference" href="../../_images/diffusor_F12.png"><img alt="../../_images/diffusor_F12.png" src="../../_images/diffusor_F12.png" style="width: 400px;" /></a>
</div>
<div class="figure align-right">
<a class="reference internal image-reference" href="../../_images/diffusor_R12.png"><img alt="../../_images/diffusor_R12.png" src="../../_images/diffusor_R12.png" style="width: 400px;" /></a>
</div>
</div>
<div class="section" id="nonlinear-equations-and-linearization">
<h2>Nonlinear equations and linearization<a class="headerlink" href="#nonlinear-equations-and-linearization" title="Permalink to this headline">¶</a></h2>
<p>One of the many advantages of using a high-level language like
<tt class="docutils literal"><span class="pre">FEniCS</span></tt> for CFD is the ease of which we can experiment with various
discretizations, coupling and linearizations of the same model. For
example, all turbulence models are highly nonlinear and coupled with
the Navier-Stokes equations. Nonlinear equations must be solved
as a sequence of linear problems, but a standard linearization
according to Newton&#8217;s method will normally fail.</p>
<p>A feasible linearization, leading to a
convergent iteration to solve the highly nonlinear equations, is not
necessarily obvious for the turbulence model in question and usually
calls for extensive trial and error. Using CBC.PDESys, the placement
of a term in a variational form - explicitly on the right hand side
of the equation system or implicitly in the coefficient matrix - is
reduced to the inclusion or not of an underscore: <tt class="docutils literal"><span class="pre">k</span></tt> means an unknown
finite element function <span class="math">\(k\)</span> (<tt class="docutils literal"><span class="pre">TrialFunction</span></tt> object), while <tt class="docutils literal"><span class="pre">k_</span></tt> is
the most recently computed approximation to <tt class="docutils literal"><span class="pre">k</span></tt> (<tt class="docutils literal"><span class="pre">Function</span></tt> object).
For example, a nonlinear term <span class="math">\(k^2\)</span> can be linearized as <tt class="docutils literal"><span class="pre">k_*k</span></tt> or
made fully known as <tt class="docutils literal"><span class="pre">k_*k_</span></tt>.  The term can also be retained as <tt class="docutils literal"><span class="pre">k*k</span></tt>
in a Newton method, where the corresponding Jacobian can be
automatically computed.</p>
<p>As opposed to most other software packages for CFD, which require
<em>user defined</em> PDEs to be solved in a segregated manner, the coupling
or splitting of a system of PDEs is in CBC.PDESys a matter of
inserting a few brackets in a little list.  As a result, experimenting
with numerics for complicated systems of nonlinear PDEs has never been
easier!</p>
</div>
<div class="section" id="implementation-details">
<h2>Implementation details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h2>
<p>There are basically three building blocks for setting up a problem
with CBC.PDESys:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">Problem</span></tt> (defines the physical problem)</li>
<li><tt class="docutils literal"><span class="pre">PDESystem</span></tt> (defines a complete system of PDEs)</li>
<li><tt class="docutils literal"><span class="pre">PDESubSystem</span></tt> (defines one variational form as a subsystem of the complete system of PDEs)</li>
</ul>
</div></blockquote>
<p>Here we will briefly explain the rationale behind these three classes.</p>
<p><tt class="docutils literal"><span class="pre">PDESubSystem</span></tt> is a class that
contains all information necessary to assemble and solve one single
variational form. In that way, a <tt class="docutils literal"><span class="pre">PDESubSystem</span></tt> is closely related to
the <tt class="docutils literal"><span class="pre">Linear/NonlinearVariationalProblem/Solver</span></tt> classes provided with
the regular Python <tt class="docutils literal"><span class="pre">dolfin</span></tt> package in FEniCS. In fact, all problems
composed of one single variational form can equally well be set up
with either approach, as demonstrated below.
The CBC.PDESys package first shows its
advantages when you need many variational forms to build your complete
mathematical model of a physical phenomenon.</p>
<p><tt class="docutils literal"><span class="pre">PDESystem</span></tt> is a class that contains a list of one or more
<tt class="docutils literal"><span class="pre">PDESubSystem</span></tt> objects. For example,
the Navier-Stokes equations can be represented through a <tt class="docutils literal"><span class="pre">PDESystem</span></tt>
object.  A coupled Navier-Stokes (NS) solver contains just one single
<tt class="docutils literal"><span class="pre">PDESubSystem</span></tt>, which is a variational form for the coupled mixed
finite element formulation for velocity and pressure. A segregated NS
solver, on the other hand, contains two <tt class="docutils literal"><span class="pre">PDESubSystem</span></tt> objects, one
for the velocity (vector field, governed by a vector PDE) and one for
the pressure (scalar field, governed by a Poisson equation).  The
<tt class="docutils literal"><span class="pre">PDESystem</span></tt> object is responsible for creating all necessary
<tt class="docutils literal"><span class="pre">FunctionSpace</span></tt>, <tt class="docutils literal"><span class="pre">TestFunction</span></tt>, and <tt class="docutils literal"><span class="pre">TrialFunction</span></tt> objects, as well
as solution (<tt class="docutils literal"><span class="pre">Function</span></tt>) objects required to solve a certain system of
PDEs.</p>
<p><tt class="docutils literal"><span class="pre">Problem</span></tt> is a class that contains the mesh and boundaries
(<tt class="docutils literal"><span class="pre">SubDomain</span></tt> objects), and that is responsible for initializing all
<tt class="docutils literal"><span class="pre">PDESystem</span></tt> objects. The class also keeps track of any common
parameters for all <tt class="docutils literal"><span class="pre">PDESystem</span></tt> objects, such as viscosity, time, and
time step.  Most importantly, the <tt class="docutils literal"><span class="pre">Problem</span></tt> class has implemented solve
functionality used to advance any number of <tt class="docutils literal"><span class="pre">PDESystem</span></tt>
objects simultaneously in time (or iterate over them in stationary problems).</p>
<p>Here is an example of how the Poisson equation
can be solved, using either standard <tt class="docutils literal"><span class="pre">dolfin</span></tt> or CBC.PDESys:</p>
<div class="highlight-py"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">cbc.pdesys</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquare</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;CG&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
<span class="n">bcs</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.</span><span class="p">),</span> <span class="n">DomainBoundary</span><span class="p">())</span>

<span class="c"># Implementation with LinearVariationalProblem/Solver</span>
<span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="n">poisson_problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">u_</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bcs</span><span class="p">)</span>
<span class="n">poisson_solver</span>  <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">poisson_problem</span><span class="p">)</span>
<span class="n">poisson_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

<span class="c"># Implementation with cbc.pdesys</span>
<span class="n">poisson</span> <span class="o">=</span> <span class="n">PDESubSystem</span><span class="p">(</span><span class="nb">vars</span><span class="p">(),</span> <span class="p">[</span><span class="s">&#39;u&#39;</span><span class="p">],</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[</span><span class="n">bcs</span><span class="p">],</span> <span class="n">F</span><span class="o">=</span><span class="n">F</span><span class="p">)</span>
<span class="n">poisson</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that the <tt class="docutils literal"><span class="pre">PDESubSystem</span></tt> takes as argument the python namespace,
<tt class="docutils literal"><span class="pre">vars()</span></tt>, containing the solution <tt class="docutils literal"><span class="pre">Function</span></tt>, <tt class="docutils literal"><span class="pre">TrialFunction</span></tt> etc.
The reason for this choice will become more evident when the same
problem is solved using both the <tt class="docutils literal"><span class="pre">PDESystem</span></tt> and <tt class="docutils literal"><span class="pre">Problem</span></tt> classes,
where such objects are created automatically by <tt class="docutils literal"><span class="pre">PDESystem</span></tt>:</p>
<div class="highlight-py"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">cbc.pdesys</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquare</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="c"># Change desired items in the problem_parameters dict from cbc.pdesys</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">Problem</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">problem_parameters</span><span class="p">)</span>
<span class="n">poisson</span> <span class="o">=</span> <span class="n">PDESystem</span><span class="p">([[</span><span class="s">&#39;u&#39;</span><span class="p">]],</span> <span class="n">problem</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="p">)</span> <span class="c"># Creates FunctionSpace, Functions etc.</span>
<span class="n">poisson</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Poisson</span><span class="p">(</span><span class="n">PDESubSystem</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v_u</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>    <span class="c"># v_u is the TestFunction</span>
        <span class="k">return</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v_u</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">f</span><span class="o">*</span><span class="n">v_u</span><span class="o">*</span><span class="n">dx</span>

<span class="n">bcs</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">poisson</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="s">&#39;u&#39;</span><span class="p">],</span> <span class="p">(</span><span class="mf">0.</span><span class="p">),</span> <span class="n">DomainBoundary</span><span class="p">())</span>
<span class="n">poisson</span><span class="o">.</span><span class="n">pdesubsystems</span><span class="p">[</span><span class="s">&#39;u&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Poisson</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="n">poisson</span><span class="p">),</span> <span class="p">[</span><span class="s">&#39;u&#39;</span><span class="p">],</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[</span><span class="n">bcs</span><span class="p">])</span>
<span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>Here the namespace <tt class="docutils literal"><span class="pre">vars(poisson)</span></tt> contains <tt class="docutils literal"><span class="pre">u</span></tt>, <tt class="docutils literal"><span class="pre">u_</span></tt>, <tt class="docutils literal"><span class="pre">v_u</span></tt> (automatically
created by initializing the <tt class="docutils literal"><span class="pre">poisson</span></tt> class) and <tt class="docutils literal"><span class="pre">f</span></tt>. The namespace is futher
provided as argument to the form method of the <tt class="docutils literal"><span class="pre">Poisson</span></tt> class.</p>
</div>
<div class="section" id="flow-past-a-dolphin">
<h2>Flow past a dolphin<a class="headerlink" href="#flow-past-a-dolphin" title="Permalink to this headline">¶</a></h2>
<p>We will now show a slightly more complicating example of how two
<tt class="docutils literal"><span class="pre">PDESystem</span></tt> objects can be created and solved through the use of a
<tt class="docutils literal"><span class="pre">Problem</span></tt> object. The physical problem regards the low Reynolds number
flow past a hot two-dimensional dolphin (where of course the simplification to
2D eliminates any physical resemblance to an actual flow past an actual dolphin).
Temperature (<span class="math">\(c\)</span>) is modeled as a passive scalar with a nonlinear
diffusion coefficient. The complete PDE system reads as follows in an
appropriately scaled form,</p>
<div class="math">
\[\begin{split}\frac{\partial {\pmb{u}}}{\partial t} + {\pmb{u}} \cdot \nabla {\pmb{u}} &amp;= \nu \nabla^2 {\pmb{u}} - \nabla p + {{\pmb{f}}}\\
\nabla\cdot \pmb{u} &amp;= 0\\
\frac{\partial c}{\partial t} + {\pmb{u}} \cdot \nabla c &amp;= \nabla\cdot\left(\nu(1+c^2)\nabla c\right)\end{split}\]</div>
<p>Discretizing these equations with a Crank-Nicolson type of scheme in time,
and redefining <span class="math">\({\pmb{u}}\)</span> to be the velocity at the new time level and <span class="math">\({\pmb{u}}_1\)</span>
the velocity at the previous time level, we arrive at these
spatial problems:</p>
<div class="math">
\[\begin{split}\frac{{\pmb{u}} - {\pmb{u}}_1}{\Delta t} + {\pmb{u}}_1 \cdot \nabla {\pmb{u}}_1  &amp;= \nu\nabla^2 {\pmb{U}} - \nabla p + {{\pmb{f}}}\\
\nabla\cdot {\pmb{U}} &amp;= 0\\
\frac{c - c_1}{\Delta t} + {\pmb{U}} \cdot \nabla C &amp;= \nabla\cdot\left(\nu(1+c^2)\nabla C\right),\end{split}\]</div>
<p>with</p>
<div class="math">
\[{\pmb{U}} = \frac{1}{2}\left( {\pmb{u}} + {\pmb{u}}_1\right),\quad C = \frac{1}{2}\left( c + c_1\right)\]</div>
<p>denoting the arithmetic averages needed in a Crank-Nicolson time
integration.
The corresponding variational formulation involves the integrals</p>
<div class="math">
\[\begin{split}\int_\Omega \left( \frac{{\pmb{u}} - {\pmb{u}}_1}{\Delta t} v_{u} +  ({\pmb{u}}_1 \cdot \nabla {\pmb{u}}_1) \cdot v_{u} +
\nu \nabla{\pmb{U}} : \nabla v_{u} - p \nabla\cdot v_{u} - {{\pmb{f}}}v_{u} +
v_p\nabla\cdot {\pmb{U}}\right)dx &amp;= 0,\\
\int_\Omega\left( \frac{c - c_1}{\Delta t}v_c + {\pmb{U}} \cdot \nabla C + \nu (1+c^2)\nabla C\cdot\nabla v_c\right)dx &amp;= 0,\end{split}\]</div>
<p>where <span class="math">\(v_{u}\)</span>, <span class="math">\(v_p\)</span>, and <span class="math">\(v_c\)</span> are test functions for the test
spaces for <span class="math">\({\pmb{u}}\)</span>, <span class="math">\(p\)</span>, and <span class="math">\(c\)</span>, respectively.</p>
<p>The implementation of this model for the flow past a dolphin can be done as follows:</p>
<div class="highlight-py"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">cbc.pdesys</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c"># Set up problem by loading mesh from file</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="s">&#39;dolfin-2.xml.gz&#39;</span><span class="p">)</span>

<span class="c"># problem_parameters are defined in Problem.py</span>
<span class="n">problem_parameters</span><span class="p">[</span><span class="s">&#39;time_integration&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Transient&quot;</span>    <span class="c"># default=&#39;Steady&#39;</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">Problem</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">problem_parameters</span><span class="p">)</span>

<span class="c"># Set up first PDESystem</span>
<span class="n">solver_parameters</span><span class="p">[</span><span class="s">&#39;space&#39;</span><span class="p">][</span><span class="s">&#39;u&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span>   <span class="c"># default=FunctionSpace</span>
<span class="n">solver_parameters</span><span class="p">[</span><span class="s">&#39;degree&#39;</span><span class="p">][</span><span class="s">&#39;u&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>                    <span class="c"># default=1</span>
<span class="n">NStokes</span> <span class="o">=</span> <span class="n">PDESystem</span><span class="p">([[</span><span class="s">&#39;u&#39;</span><span class="p">,</span> <span class="s">&#39;p&#39;</span><span class="p">]],</span> <span class="n">problem</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="p">)</span>

<span class="c"># Use a constant forcing field to drive the flow from right to left</span>
<span class="n">NStokes</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">((</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span>

<span class="c"># No-slip boundary condition for velocity on the dolfin</span>
<span class="n">dolfin</span> <span class="o">=</span> <span class="n">AutoSubDomain</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">:</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="ow">not</span>
                       <span class="p">(</span><span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.</span><span class="p">)</span> <span class="ow">or</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">)</span> <span class="ow">or</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.</span><span class="p">)))</span>

<span class="n">bc</span> <span class="o">=</span> <span class="p">[</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">NStokes</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="s">&#39;up&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Constant</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)),</span> <span class="n">dolfin</span><span class="p">)]</span>

<span class="c"># Set up variational form.</span>
<span class="c"># u_, u_1 are the solution Functions at time steps N and N-1.</span>
<span class="c"># v_u/v_p are the TestFunctions for velocity/pressure in the MixedFunctionSpace for u and p</span>

<span class="n">NStokes</span><span class="o">.</span><span class="n">nu</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">NavierStokes</span><span class="p">(</span><span class="n">PDESubSystem</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v_u</span><span class="p">,</span> <span class="n">u_</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">v_p</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">U</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">v_u</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> \
               <span class="n">inner</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">u_1</span><span class="p">,</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">u_1</span><span class="p">)),</span> <span class="n">v_u</span><span class="p">)</span> <span class="o">+</span> \
               <span class="n">nu</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">U</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v_u</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> \
               <span class="n">inner</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">div</span><span class="p">(</span><span class="n">v_u</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">inner</span><span class="p">(</span><span class="n">div</span><span class="p">(</span><span class="n">U</span><span class="p">),</span> <span class="n">v_p</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> \
               <span class="n">inner</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">v_u</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>

<span class="n">NStokes</span><span class="o">.</span><span class="n">pdesubsystems</span><span class="p">[</span><span class="s">&#39;up&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">NavierStokes</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="n">NStokes</span><span class="p">),</span> <span class="p">[</span><span class="s">&#39;u&#39;</span><span class="p">,</span> <span class="s">&#39;p&#39;</span><span class="p">],</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bc</span><span class="p">,</span>
                                           <span class="n">reassemble_lhs</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c"># Integrate the solution from t=0 to t=0.5</span>
<span class="n">problem</span><span class="o">.</span><span class="n">prm</span><span class="p">[</span><span class="s">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

<span class="c"># Define a new nonlinear PDESystem for a scalar c</span>
<span class="n">scalar</span> <span class="o">=</span> <span class="n">PDESystem</span><span class="p">([[</span><span class="s">&#39;c&#39;</span><span class="p">]],</span> <span class="n">problem</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Scalar</span><span class="p">(</span><span class="n">PDESubSystem</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">v_c</span><span class="p">,</span> <span class="n">c_</span><span class="p">,</span> <span class="n">c_1</span><span class="p">,</span> <span class="n">U_</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">C</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">c_1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">c_1</span><span class="p">,</span> <span class="n">v_c</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> \
                <span class="n">inner</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">U_</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">C</span><span class="p">)),</span> <span class="n">v_c</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> \
                <span class="n">nu</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">c_</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">C</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v_c</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
                <span class="c"># Note nonlinearity in c_ (above)</span>

<span class="n">bcc</span> <span class="o">=</span> <span class="p">[</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">scalar</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">],</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">dolfin</span><span class="p">)]</span>

<span class="n">scalar</span><span class="o">.</span><span class="n">U_</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">NStokes</span><span class="o">.</span><span class="n">u_</span> <span class="o">+</span> <span class="n">NStokes</span><span class="o">.</span><span class="n">u_1</span><span class="p">)</span> <span class="c"># The Scalar form uses the velocity</span>
<span class="n">scalar</span><span class="o">.</span><span class="n">nu</span> <span class="o">=</span> <span class="n">NStokes</span><span class="o">.</span><span class="n">nu</span>
<span class="n">csub1</span> <span class="o">=</span> <span class="n">Scalar</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="n">scalar</span><span class="p">),</span> <span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">],</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bcc</span><span class="p">,</span> <span class="n">max_inner_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="c"># Iterate on c_</span>
<span class="n">scalar</span><span class="o">.</span><span class="n">pdesubsystems</span><span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">csub1</span>

<span class="c"># Integrate both PDESystems from t=0.5 to t=1.0 using Picard</span>
<span class="c"># iterations on each time step</span>
<span class="n">problem</span><span class="o">.</span><span class="n">prm</span><span class="p">[</span><span class="s">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

<span class="c"># Switch to using the Newton method for the nonlinear variational form</span>
<span class="c"># With these calls we replace c by c_ in the Scalar form and compute the Jacobian wrt c_</span>
<span class="n">csub1</span><span class="o">.</span><span class="n">prm</span><span class="p">[</span><span class="s">&#39;iteration_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Newton&#39;</span>
<span class="n">csub1</span><span class="o">.</span><span class="n">define</span><span class="p">()</span>

<span class="c"># Integrate both PDESystems from T=1.0 to T=1.5 using Newton</span>
<span class="c"># iterations on each time step for the scalar</span>
<span class="n">problem</span><span class="o">.</span><span class="n">prm</span><span class="p">[</span><span class="s">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-right">
<a class="reference internal image-reference" href="../../_images/dolfin_temp.gif"><img alt="../../_images/dolfin_temp.gif" src="../../_images/dolfin_temp.gif" style="width: 360px;" /></a>
</div>
<p>The temporal evolution of the temperature is illustrated on the
figure to the right.</p>
<p>There are a few interesting features of CBC.PDESys at display
here. First, in the creation of <tt class="docutils literal"><span class="pre">NStokes</span></tt> (<tt class="docutils literal"><span class="pre">PDESystem</span></tt> object), we
request a coupled system of PDEs (using <tt class="docutils literal"><span class="pre">MixedFunctionSpace</span></tt>)
consisting of the vector <tt class="docutils literal"><span class="pre">u</span></tt> and the scalar <tt class="docutils literal"><span class="pre">p</span></tt> (scalar is default
option). A segregated system, on the other hand, would require the
list <tt class="docutils literal"><span class="pre">[['u'],</span> <span class="pre">['p']]</span></tt> being sent to the <tt class="docutils literal"><span class="pre">PDESystem</span></tt> object to indicate
that <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">p</span></tt> are solved in sequence, i.e., in a segregated way. The
<tt class="docutils literal"><span class="pre">solver_parameters</span></tt> dictionary contains many dictionaries, with default
values for many of the options. The dictionaries use the
names of the variables (here <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">p</span></tt>) as keys. <tt class="docutils literal"><span class="pre">FunctionSpace</span></tt> is
the default option for the <tt class="docutils literal"><span class="pre">space</span></tt> dictionary and <tt class="docutils literal"><span class="pre">1</span></tt> for the <tt class="docutils literal"><span class="pre">degree</span></tt>
dictionary (polynomial order of the basis functions), and as such we
need only specify new values for <tt class="docutils literal"><span class="pre">u</span></tt>.</p>
<p>The variational form is hooked up by subclassing the <tt class="docutils literal"><span class="pre">PDESubSystem</span></tt>
class and overloading the <tt class="docutils literal"><span class="pre">form</span></tt> method that returns the variational
form. The <tt class="docutils literal"><span class="pre">PDESubSystem</span></tt> class contains numerous methods and switches
for optimization of finite element assembly and solving linear or nonlinear
system arising from the form.
Since the Navier-Stokes equations being solved here are discretized with
explicit convection,
the left hand side coefficient matrix will not change in time. When we provide this
information (through <tt class="docutils literal"><span class="pre">reassemble_lhs=False</span></tt>), the coefficient matrix will
only be assembled on the first time step.</p>
<p>One major advantage of placing numerical schemes as methods in a
variational form class is the ease of which we can manipulate and
store numerous different discretizations. The classes of numerical
schemes are typically kept in a single file, or Python module (e.g.,
<tt class="docutils literal"><span class="pre">NavierStokes.py</span></tt>), and can be retrieved as required. So if we in the future
need to solve the Navier-Stokes equations together with other PDEs, then we
can simply pull the scheme from <tt class="docutils literal"><span class="pre">NavierStokes.py</span></tt> and reuse it. This is not
possible with the standard <tt class="docutils literal"><span class="pre">dolfin</span></tt> implementation displayed
above. For turbulent flow models, we would like to set up our problem
and then select the appropriate turbulence model and numerics from a
predefined library. Each turbulence model will then have a main
<tt class="docutils literal"><span class="pre">PDESystem</span></tt> class and a library of possible transient and steady
schemes that can be picked at runtime.</p>
<p>Note that implementing a new problem through CBC.PDESys generally
will not require redefining the variational
forms as done above (<tt class="docutils literal"><span class="pre">Scalar</span></tt> and <tt class="docutils literal"><span class="pre">NavierStokes</span></tt>). Instead the user will
be required to set up a mesh and its boundaries, pick <tt class="docutils literal"><span class="pre">PDESystem's</span></tt>
from modules, initialize and solve. In the end this leads to very compact,
flexible and, most importantly, reusable code.</p>
</div>
<div class="section" id="rans-models">
<h2>RANS models<a class="headerlink" href="#rans-models" title="Permalink to this headline">¶</a></h2>
<p>Most industrial flows have high Reynolds number and are
far too complex for all details of the flow to be fully resolved. For
this reason researchers have developed simplified models representing
the most relevant statistical properties of the flow, like the mean
velocity and the mean turbulent kinetic energy. The largest family of
such models are the Reynolds Averaged Navier Stokes (RANS)
equations.  There are hundreds of different RANS models, each
represented by a system of nonlinear PDEs, coupling statistical
turbulence quantities with the mean flow.</p>
<p>There is a hierarchy of turbulence models. So-called eddy-viscosity (EV) models
close the Reynolds stress through the following formula:</p>
<div class="math">
\[\overline{u'_i u'_j} = - \nu_T\left( \frac{\partial \overline{u_i}}{\partial x_j} + \frac{\partial \overline{u_j}}{\partial x_i} \right) + \frac{1}{3}\delta_{ij} \overline{u'_k u'_k}\]</div>
<p>Eddy-viscosity models are usually classified by the number of additional
PDEs that are required to close an expression for the turbulent viscosity <span class="math">\(\nu_T\)</span>.
Reynolds stress models, like the elliptic relaxation model outlined above, solves
a PDE for the second rank tensor <span class="math">\(\overline{u'_i u'_j}\)</span> and do not make
use of the eddy-viscosity model. Using CBC.PDESys we have currently implemented
the following turbulence models in <tt class="docutils literal"><span class="pre">cbc.rans</span></tt>:</p>
<ol class="arabic">
<li><p class="first">One-equation EV models</p>
<blockquote>
<div><ul class="simple">
<li>Spalart-Allmaras</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Two-equation EV models</p>
<blockquote>
<div><ul class="simple">
<li>Standard k-epsilon</li>
<li>Low-Reynolds k-epsilon (3 different)</li>
<li>Menter&#8217;s SST</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Four-equation EV models</p>
<blockquote>
<div><ul class="simple">
<li>V2F (2 different)</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Reynolds stress models</p>
<blockquote>
<div><ul class="simple">
<li>Standard</li>
<li>Elliptic relaxation</li>
</ul>
</div></blockquote>
</li>
</ol>
<p>The tutorial <a class="reference external" href="http://bazaar.launchpad.net/~cbc.rans/cbc.rans/mikael/view/head:/doc/overview/cbc.rans-MekIT11.pdf">cbc.rans-MekIT11.pdf</a> on using <tt class="docutils literal"><span class="pre">cbc.rans</span></tt> to implement
advanced turbulence models was published in the
proceedings of the 6th National Conference on Computational
Mechanics, 2011 (MekIT&#8216;11).</p>
<p>The interested reader will also learn more about the inner workings
of the <tt class="docutils literal"><span class="pre">cbc.rans</span></tt> package by studying the recently published paper <a class="reference external" href="http://arxiv.org/abs/1102.2933">A FEniCS-Based Programming Framework for Modeling Turbulent Flow by the Reynolds-Averaged Navier-Stokes Equations</a> (<em>Advances in Water Resources</em>, 2011, DOI: 10.1016/j.advwatres.2011.02.013).</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="wrapper">
  <div class="footer">
    <div class="footer-nav">
      <div class="span-6">
	<h4>Usage documentation</h4>
	<ul>
	  <li><a href="/documentation/tutorial/">Tutorial</a></li>
	  <li><a href="/documentation/dolfin/dev/python/">Python API</a></li>
	  <li><a href="/documentation/dolfin/dev/cpp/">C++ API</a></li>
          <li><a href="/releases/">Release notes</a></li>
	</ul>
      </div>
      <div class="span-6">
	<h4>Developer resources</h4>
	<ul>
	  <li><a href="/buildbot/">Buildbot</a></li>
	  <li><a href="/benchbot/">Benchbot</a></li>
	  <li><a href="https://bitbucket.org/fenics-project/">FEniCS on Bitbucket</a></li>
	  <li><a href="/pub/">File archive</a></li>
	</ul>
      </div>
      <div class="span-6 last">
	<h4>Search this site</h4>
	<div id="searchbox">
	  <form class="search" action="/search.html" method="get">
	    <input type="text" name="q" size="18" />
	    <input type="submit" value="Go" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	</div>
      </div>
    </div>
    &copy; Copyright 2015, <a href="/">The FEniCS Project</a>. (<a href="/disclaimer.html">Disclaimer</a>)
  </div>
</div>

  </body>
</html>