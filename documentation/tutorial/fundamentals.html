<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Fundamentals &mdash; FEniCS Project</title>
    
    <link rel="stylesheet" href="../../_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.9.9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="FEniCS Project" href="../../index.html" />
    <link rel="up" title="FEniCS tutorial (Python)" href="index.html" />
    <link rel="next" title="Nonlinear Problems" href="nonlinear.html" />
    <link rel="prev" title="FEniCS tutorial (Python)" href="index.html" />



<link rel="shortcut icon" href="../../_static/fenics.ico" />


<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-19595948-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </head>
  <body>
<div class="wrapper">
  <a href="/"><img src="../../_static/fenics_banner.png" width="900px" alt="FEniCS Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
	<li class="page_item"><a href="/about/" title="Find out more about the FEniCS project">About</a></li>
	<li class="page_item"><a href="/download/" title="Obtain the FEniCS project">Download</a></li>
	<li class="page_item"><a href="/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
	<li class="page_item"><a href="/applications/" title="Learn how others are using the FEniCS project">Applications</a></li>
	<li class="page_item"><a href="/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
	<li class="page_item"><a href="/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
	<li class="page_item"><a href="/support/" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="fundamentals">
<span id="tut-fundamentals"></span><h1>Fundamentals<a class="headerlink" href="#fundamentals" title="Permalink to this headline">¶</a></h1>
<p>FEniCS is a user-friendly tool for solving partial differential
equations (PDEs). The goal of this tutorial is to get you started with
FEniCS through a series of simple examples that demonstrate</p>
<blockquote>
<div><ul class="simple">
<li>how to define the PDE problem in terms of a variational problem,</li>
<li>how to define simple domains,</li>
<li>how to deal with Dirichlet, Neumann, and Robin conditions,</li>
<li>how to deal with variable coefficients,</li>
<li>how to deal with domains built of several materials (subdomains),</li>
<li>how to compute derived quantities like the flux vector field or
a functional of the solution,</li>
<li>how to quickly visualize the mesh, the solution, the flux, etc.,</li>
<li>how to solve nonlinear PDEs in various ways,</li>
<li>how to deal with time-dependent PDEs,</li>
<li>how to set parameters governing solution methods for linear
systems,</li>
<li>how to create domains of more complex shape.</li>
</ul>
</div></blockquote>
<p>The mathematics of the illustrations is kept simple to better focus on
FEniCS functionality and syntax. This means that we mostly use the
Poisson equation and the time-dependent diffusion equation as model
problems, often with input data adjusted such that we get a very
simple solution that can be exactly reproduced by any standard finite
element method over a uniform, structured mesh. This latter property
greatly simplifies the verification of the implementations.
Occasionally we insert a physically more relevant example to remind
the reader that changing the PDE and boundary conditions to something
more real might often be a trivial task.</p>
<p>FEniCS may seem to require a thorough understanding of the abstract
mathematical version of the finite element method as well as
familiarity with the Python programming language.  Nevertheless, it
turns out that many are able to pick up the fundamentals of finite
elements <em>and</em> Python programming as they go along with this
tutorial. Simply keep on reading and try out the examples. You will be
amazed of how easy it is to solve PDEs with FEniCS!</p>
<p>Reading this tutorial obviously requires access to a machine where the
FEniCS software is installed. The section <a class="reference internal" href="misc.html#tut-app-install"><em>Installing FEniCS</em></a>
explains briefly how to install the necessary tools.</p>
<p>All the examples discussed in the following are available as
executable Python source code files in a directory tree.</p>
<div class="section" id="the-poisson-equation">
<span id="tut-poisson1-bvp"></span><h2>The Poisson equation<a class="headerlink" href="#the-poisson-equation" title="Permalink to this headline">¶</a></h2>
<p id="index-0">Our first example regards the Poisson problem,</p>
<div class="math">
\[\begin{split}- \nabla^2 u(\pmb{x}) &amp;= f(\pmb{x}),\quad \pmb{x}\mbox{ in } \Omega,
\\
u(\pmb{x}) &amp;= u_0(\pmb{x}),\quad \pmb{x}\mbox{ on } \partial \Omega\thinspace .\end{split}\]</div>
<p>Here, <span class="math">\(u(\pmb{x})\)</span> is the unknown function, <span class="math">\(f(\pmb{x})\)</span>
is a prescribed function, <span class="math">\(\nabla^2\)</span> is the Laplace operator
(also often written as <span class="math">\(\Delta\)</span>), <span class="math">\(\Omega\)</span> is the spatial
domain, and <span class="math">\(\partial\Omega\)</span> is the boundary of
<span class="math">\(\Omega\)</span>. A stationary PDE like this, together with a complete
set of boundary conditions, constitute a <em>boundary-value problem</em>,
which must be precisely stated before it makes sense to start solving
it with FEniCS.</p>
<p>In two space dimensions with coordinates <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, we
can write out the Poisson equation as</p>
<div class="math">
\[- {\partial^2 u\over\partial x^2} -
{\partial^2 u\over\partial y^2} = f(x,y)\thinspace .\]</div>
<p>The unknown <span class="math">\(u\)</span> is now a function of two variables,
<span class="math">\(u(x,y)\)</span>, defined over a two-dimensional domain <span class="math">\(\Omega\)</span>.</p>
<p>The Poisson equation arises in numerous physical contexts, including
heat conduction, electrostatics, diffusion of substances, twisting of
elastic rods, inviscid fluid flow, and water waves. Moreover, the
equation appears in numerical splitting strategies of more complicated
systems of PDEs, in particular the Navier-Stokes equations.</p>
<p>Solving a physical problem with FEniCS consists of the following
steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Identify the PDE and its boundary conditions.</li>
<li>Reformulate the PDE problem as a variational problem.</li>
<li>Make a Python program where the formulas in the variational
problem are coded, along with definitions of input data such as
<span class="math">\(f\)</span>, <span class="math">\(u_0\)</span>, and a mesh for the spatial domain
<span class="math">\(\Omega\)</span>.</li>
<li>Add statements in the program for solving the variational problem,
computing derived quantities such as <span class="math">\(\nabla u\)</span>, and
visualizing the results.</li>
</ol>
</div></blockquote>
<p>We shall now go through steps 2&#8211;4 in detail.  The key feature of
FEniCS is that steps 3 and 4 result in fairly short code, while most
other software frameworks for PDEs require much more code and more
technically difficult programming.</p>
</div>
<div class="section" id="variational-formulation">
<span id="tut-poisson1-varform"></span><h2>Variational Formulation<a class="headerlink" href="#variational-formulation" title="Permalink to this headline">¶</a></h2>
<p id="index-1">FEniCS makes it easy to solve PDEs if finite elements are used for
discretization in space and the problem is expressed as a <em>variational
problem</em>. Readers who are not familiar with variational problems will
get a brief introduction to the topic in this tutorial, but getting
and reading a proper book on the finite element method in addition is
encouraged. The section <a class="reference internal" href="misc.html#tut-appendix-books"><em>Books on the Finite Element Method</em></a> contains a list of
some suitable books.</p>
<span class="target" id="index-2"></span><p id="index-3">The core of the recipe for turning a PDE into a variational problem is
to multiply the PDE by a function <span class="math">\(v\)</span>, integrate the resulting
equation over <span class="math">\(\Omega\)</span>, and perform integration by parts of
terms with second-order derivatives. The function <span class="math">\(v\)</span> which
multiplies the PDE is in the mathematical finite element literature
called a <em>test function</em>. The unknown function <span class="math">\(u\)</span> to be
approximated is referred to as a <em>trial function</em>. The terms test and
trial function are used in FEniCS programs too.  Suitable function
spaces must be specified for the test and trial functions.  For
standard PDEs arising in physics and mechanics such spaces are well
known.</p>
<p>In the present case, we first multiply the Poisson equation by the
test function <span class="math">\(v\)</span> and integrate,</p>
<div class="math" id="equation-tut:poisson1:multbyv">
<span class="eqno">(1)</span>\[      -\int_\Omega (\nabla^2 u)v \, \mathrm{d}x = \int_\Omega fv \, \mathrm{d}x\thinspace .\]</div>
<p>Then we apply integration by parts to the integrand with second-order
derivatives,</p>
<div class="math" id="equation-tut:poisson1:eqbyparts">
<span class="eqno">(2)</span>\[      -\int_\Omega (\nabla^2 u)v \, \mathrm{d}x
     = \int_\Omega\nabla u\cdot\nabla v \, \mathrm{d}x - \int_{\partial\Omega}{\partial u\over
     \partial n}v \, \mathrm{d}s ,\]</div>
<p>where <span class="math">\({\partial u\over \partial n}\)</span> is the derivative of
<span class="math">\(u\)</span> in the outward normal direction at the boundary.  The test
function <span class="math">\(v\)</span> is required to vanish on the parts of the boundary
where <span class="math">\(u\)</span> is known, which in the present problem implies that
<span class="math">\(v=0\)</span> on the whole boundary <span class="math">\(\partial\Omega\)</span>.  The second
term on the right-hand side of the last equation therefore
vanishes. It then follows that</p>
<div class="math" id="equation-tut:poisson1:weak1 \int_\Omega\nabla u\cdot\nabla v \, \mathrm{d}x = \int_\Omega fv \, \mathrm{d}x\thinspace .">
</div>
<p>This equation is supposed to hold for all <span class="math">\(v\)</span> in some function
space <span class="math">\(\hat V\)</span>. The trial function <span class="math">\(u\)</span> lies in some
(possibly different) function space <span class="math">\(V\)</span>.  We say that the last
equation is the <em>weak form</em> of the original boundary value problem
consisting of the PDE <span class="math">\(-\nabla^2u=f\)</span> and the boundary condition
<span class="math">\(u=u_0\)</span>.</p>
<p>The proper statement of our variational problem now goes as follows:
Find <span class="math">\(u \in V\)</span> such that</p>
<div class="math" id="equation-tut:poisson1:var">
<span class="eqno">(4)</span>\[       \int_{\Omega} \nabla u \cdot \nabla v \, \mathrm{d}x =
       \int_{\Omega} fv \, \mathrm{d}x
       \quad \forall v \in \hat{V}.\]</div>
<p>The test and trial spaces <span class="math">\(\hat{V}\)</span> and <span class="math">\(V\)</span> are in the
present problem defined as</p>
<div class="math">
\[\begin{split}\hat{V} &amp;= \{v \in H^1(\Omega) : v = 0 \mbox{ on } \partial\Omega\}, \\
 V      &amp;= \{v \in H^1(\Omega) : v = u_0 \mbox{ on } \partial\Omega\}\thinspace .\end{split}\]</div>
<p>In short, <span class="math">\(H^1(\Omega)\)</span> is the mathematically well-known Sobolev
space containing functions <span class="math">\(v\)</span> such that <span class="math">\(v^2\)</span> and
<span class="math">\(||\nabla v||^2\)</span> have finite integrals over <span class="math">\(\Omega\)</span>. The
solution of the underlying PDE must lie in a function space where also
the derivatives are continuous, but the Sobolev space
<span class="math">\(H^1(\Omega)\)</span> allows functions with discontinuous derivatives.
This weaker continuity requirement of <span class="math">\(u\)</span> in the variational
statement, caused by the integration by parts, has great practical
consequences when it comes to constructing finite elements.</p>
<p>To solve the Poisson equation numerically, we need to transform the
continuous variational problem to a discrete variational problem. This
is done by introducing <em>finite-dimensional</em> test and trial spaces,
often denoted as <span class="math">\(\hat{V}_h\subset\hat{V}\)</span> and
<span class="math">\(V_h\subset{V}\)</span>. The discrete variational problem reads: Find
<span class="math">\(u_h \in V_h \subset V\)</span> such that</p>
<div class="math" id="equation-tut:poisson1:vard">
<span class="eqno">(5)</span>\[       \int_{\Omega} \nabla u_h \cdot \nabla v \, \mathrm{d}x =
       \int_{\Omega} fv \, \mathrm{d}x
       \quad \forall v \in \hat{V}_h \subset \hat{V}\thinspace .\]</div>
<p>The choice of <span class="math">\(\hat{V}_h\)</span> and <span class="math">\(V_h\)</span> follows directly from
the kind of finite elements we want to apply in our problem. For
example, choosing the well-known linear triangular element with three
nodes implies that <span class="math">\(\hat V_h\)</span> and <span class="math">\(V_h\)</span> are the spaces of
all piecewise linear functions over a mesh of triangles, where the
functions in <span class="math">\(\hat V_h\)</span> are zero on the boundary and those in
<span class="math">\(V_h\)</span> equal <span class="math">\(u_0\)</span> on the boundary.</p>
<p>The mathematics literature on variational problems writes <span class="math">\(u_h\)</span>
for the solution of the discrete problem and <span class="math">\(u\)</span> for the
solution of the continuous problem. To obtain (almost) a one-to-one
relationship between the mathematical formulation of a problem and the
corresponding FEniCS program, we shall use <span class="math">\(u\)</span> for the solution
of the discrete problem and <span class="math">\(u_{e}\)</span> for the exact solution of
the continuous problem, <em>if</em> we need to explicitly distinguish between
the two.  In most cases, we will introduce the PDE problem with
<span class="math">\(u\)</span> as unknown, derive a variational equation
<span class="math">\(a(u,v)=L(v)\)</span> with <span class="math">\(u\in V\)</span> and <span class="math">\(v\in \hat V\)</span>, and
then simply discretize the problem by saying that we choose
finite-dimensional spaces for <span class="math">\(V\)</span> and <span class="math">\(\hat V\)</span>. This
restriction of <span class="math">\(V\)</span> implies that <span class="math">\(u\)</span> becomes a discrete
finite element function.  In practice, this means that we turn our PDE
problem into a continuous variational problem, create a mesh and
specify an element type, and then let <span class="math">\(V\)</span> correspond to this
mesh and element choice.  Depending upon whether <span class="math">\(V\)</span> is
infinite- or finite-dimensional, <span class="math">\(u\)</span> will be the exact or
approximate solution.</p>
<p>It turns out to be convenient to introduce the following unified
notation for linear weak forms:</p>
<div class="math">
\[a(u, v) = L(v)\thinspace .\]</div>
<p>In the present problem we have that</p>
<div class="math">
\[\begin{split}a(u, v) &amp;= \int_{\Omega} \nabla u \cdot \nabla v \, \mathrm{d}x,
\\
L(v) &amp;= \int_{\Omega} fv \, \mathrm{d}x\thinspace .\end{split}\]</div>
<p>From the mathematics literature, <span class="math">\(a(u,v)\)</span> is known as a
<em>bilinear form</em> and <span class="math">\(L(v)\)</span> as a <em>linear form</em>.  We shall in
every linear problem we solve identify the terms with the unknown
<span class="math">\(u\)</span> and collect them in <span class="math">\(a(u,v)\)</span>, and similarly collect
all terms with only known functions in <span class="math">\(L(v)\)</span>. The formulas for
<span class="math">\(a\)</span> and <span class="math">\(L\)</span> are then coded directly in the program.</p>
<p>To summarize, before making a FEniCS program for solving a PDE, we
must first perform two steps:</p>
<blockquote>
<div><ul class="simple">
<li>Turn the PDE problem into a discrete variational problem: find
<span class="math">\(u\in V\)</span> such that <span class="math">\(a(u,v) = L(v)\quad\forall v\in
\hat{V}\)</span>.</li>
<li>Specify the choice of spaces (<span class="math">\(V\)</span> and <span class="math">\(\hat V\)</span>), which
means specifying the mesh and type of finite elements.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="implementation-1">
<span id="tut-poisson1-impl"></span><h2>Implementation (1)<a class="headerlink" href="#implementation-1" title="Permalink to this headline">¶</a></h2>
<p id="index-4">The test problem so far has a general domain <span class="math">\(\Omega\)</span> and
general functions <span class="math">\(u_0\)</span> and <span class="math">\(f\)</span>. For our first
implementation we must decide on specific choices of <span class="math">\(\Omega\)</span>,
<span class="math">\(u_0\)</span>, and <span class="math">\(f\)</span>.  It will be wise to construct a specific
problem where we can easily check that the computed solution is
correct. Let us start with specifying an exact solution</p>
<div class="math" id="equation-tut:poisson1:impl:uex">
<span class="eqno">(6)</span>\[     u_{\rm e}(x, y) = 1 +x^2 + 2y^2\]</div>
<p>on some 2D domain.  By inserting eq:ref:<cite>tut:poisson1:impl:uex</cite> in
our Poisson problem, we find that <span class="math">\(u_{\rm e}(x,y)\)</span> is a solution
if</p>
<div class="math">
\[f(x,y) = -6,\quad u_0(x,y)=u_{\rm e}(x,y)=1 + x^2 + 2y^2,\]</div>
<p>regardless of the shape of the domain. We choose here, for simplicity,
the domain to be the unit square,</p>
<div class="math">
\[\Omega = [0,1]\times [0,1] .\]</div>
<p>The reason for specifying the solution eq:ref:<cite>tut:poisson1:impl:uex</cite>
is that the finite element method, with a rectangular domain uniformly
partitioned into linear triangular elements, will exactly reproduce a
second-order polynomial at the vertices of the cells, regardless of
the size of the elements. This property allows us to verify the
implementation by comparing the computed solution, called <span class="math">\(u\)</span> in
this document (except when setting up the PDE problem), with the exact
solution, denoted by <span class="math">\(u_{\rm e}\)</span>: <span class="math">\(u\)</span> should equal
<span class="math">\(u_{\rm}\)</span> to machine precision emph{at the nodes}.  Test
problems with this property will be frequently constructed throughout
this tutorial.</p>
<p>A FEniCS program for solving the Poisson equation in 2D with the given
choices of <span class="math">\(u_0\)</span>, <span class="math">\(f\)</span>, and <span class="math">\(\Omega\)</span> may look as
follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">FEniCS tutorial demo program: Poisson equation with Dirichlet conditions.</span>
<span class="sd">Simplest example of computation and visualization with FEniCS.</span>

<span class="sd">-Laplace(u) = f on the unit square.</span>
<span class="sd">u = u0 on the boundary.</span>
<span class="sd">u0 = u = 1 + x^2 + 2y^2, f = -6.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c"># Create mesh and define function space</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquare</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="c">#mesh = UnitCube(6, 4, 5)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c"># Define boundary conditions</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>

<span class="c"># Define variational problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="c"># Compute solution</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

<span class="c"># Plot solution and mesh</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="c"># Dump solution to file in VTK format</span>
<span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&#39;poisson.pvd&#39;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>

<span class="c"># Hold plot</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The complete code can be found in the file <tt class="docutils literal"><span class="pre">d1_p2D.py</span></tt> in the
directory <tt class="docutils literal"><span class="pre">stationary/poisson</span></tt>.</p>
<p>We shall now dissect this FEniCS program in detail. The program is
written in the Python programming language.  You may either take a
quick look at the <a class="reference external" href="http://docs.python.org/tutorial/">official Python tutorial</a> to pick up the basics of Python
if you are unfamiliar with the language, or you may learn enough
Python as you go along with the examples in the present tutorial. The
latter strategy has proven to work for many newcomers to FEniCS. (The
requirement of using Python and an abstract mathematical formulation
of the finite element problem may seem difficult for those who are
unfamiliar with these topics.  However, the amount of mathematics and
Python that is really demanded to get you productive with FEniCS is
quite limited.  And Python is an easy-to-learn language that you
certainly will love and use far beyond FEniCS programming.)  the
section <a class="reference internal" href="misc.html#tut-appendix-pybooks"><em>Books on Python</em></a> lists some relevant Python books.</p>
<p>The listed FEniCS program defines a finite element mesh, the discrete
function spaces <span class="math">\(V\)</span> and <span class="math">\(\hat{V}\)</span> corresponding to this
mesh and the element type, boundary conditions for <span class="math">\(u\)</span> (the
function <span class="math">\(u_0\)</span>), <span class="math">\(a(u,v)\)</span>, and <span class="math">\(L(v)\)</span>.  Thereafter,
the unknown trial function <span class="math">\(u\)</span> is computed. Then we can
investigate <span class="math">\(u\)</span> visually or analyze the computed values.</p>
<p>The first line in the program,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>imports the key classes <tt class="docutils literal"><span class="pre">UnitSquare</span></tt>, <tt class="docutils literal"><span class="pre">FunctionSpace</span></tt>,
<tt class="docutils literal"><span class="pre">Function</span></tt>, and so forth, from the DOLFIN library.  All FEniCS
programs for solving PDEs by the finite element method normally start
with this line. DOLFIN is a software library with efficient and
convenient C++ classes for finite element computing, and <tt class="docutils literal"><span class="pre">dolfin</span></tt> is
a Python package providing access to this C++ library from Python
programs.  You can think of FEniCS as an umbrella, or project name,
for a set of computational components, where DOLFIN is one important
component for writing finite element programs. The <tt class="docutils literal"><span class="pre">from</span> <span class="pre">dolfin</span>
<span class="pre">import</span> <span class="pre">*</span></tt> statement imports other components too, but newcomers to
FEniCS programming do not need to care about this.</p>
<span class="target" id="index-5"></span><p id="index-6">The statement</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquare</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>defines a uniform finite element mesh over the unit square
<span class="math">\([0,1]\times [0,1]\)</span>. The mesh consists of <em>cells</em>, which are
triangles with straight sides. The parameters 6 and 4 tell that the
square is first divided into <span class="math">\(6\times 4\)</span> rectangles, and then
each rectangle is divided into two triangles. The total number of
triangles then becomes 48. The total number of vertices in this mesh
is <span class="math">\(7\cdot 5=35\)</span>.  DOLFIN offers some classes for creating
meshes over very simple geometries. For domains of more complicated
shape one needs to use a separate <em>preprocessor</em> program to create the
mesh.  The FEniCS program will then read the mesh from file.</p>
<p id="index-7">Having a mesh, we can define a discrete function space <tt class="docutils literal"><span class="pre">V</span></tt> over this
mesh:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The second argument reflects the type of element, while the third
argument is the degree of the basis functions on the element.</p>
<span class="target" id="index-8"></span><span class="target" id="index-9"></span><p id="index-10">The type of element is here &#8220;Lagrange&#8221;, implying the standard Lagrange
family of elements.  (Some FEniCS programs use <tt class="docutils literal"><span class="pre">'CG'</span></tt>, for
Continuous Galerkin, as a synonym for <tt class="docutils literal"><span class="pre">'Lagrange'</span></tt>.)  With degree 1,
we simply get the standard linear Lagrange element, which is a
triangle with nodes at the three vertices.  Some finite element
practitioners refer to this element as the &#8220;linear triangle&#8221;.  The
computed <span class="math">\(u\)</span> will be continuous and linearly varying in
<span class="math">\(x\)</span> and <span class="math">\(y\)</span> over each cell in the mesh.  Higher-degree
polynomial approximations over each cell are trivially obtained by
increasing the third parameter in <tt class="docutils literal"><span class="pre">FunctionSpace</span></tt>. Changing the
second parameter to <tt class="docutils literal"><span class="pre">'DG'</span></tt> creates a function space for
discontinuous Galerkin methods.</p>
<span class="target" id="index-11"></span><span class="target" id="index-12"></span><span class="target" id="index-13"></span><p id="index-14">In mathematics, we distinguish between the trial and test spaces
<span class="math">\(V\)</span> and <span class="math">\(\hat{V}\)</span>. The only difference in the present
problem is the boundary conditions. In FEniCS we do not specify the
boundary conditions as part of the function space, so it is sufficient
to work with one common space <tt class="docutils literal"><span class="pre">V</span></tt> for the and trial and test
functions in the program:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-15">The next step is to specify the boundary condition: <span class="math">\(u=u_0\)</span> on
<span class="math">\(\partial\Omega\)</span>. This is done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">u0</span></tt> is an instance holding the <span class="math">\(u_0\)</span> values, and
<tt class="docutils literal"><span class="pre">u0_boundary</span></tt> is a function (or object) describing whether a point
lies on the boundary where <span class="math">\(u\)</span> is specified.</p>
<p>Boundary conditions of the type <span class="math">\(u=u_0\)</span> are known as <em>Dirichlet
conditions</em>, and also as <em>essential boundary conditions</em> in a finite
element context.  Naturally, the name of the DOLFIN class holding the
information about Dirichlet boundary conditions is <tt class="docutils literal"><span class="pre">DirichletBC</span></tt>.</p>
<p id="index-16">The <tt class="docutils literal"><span class="pre">u0</span></tt> variable refers to an <tt class="docutils literal"><span class="pre">Expression</span></tt> object, which is used
to represent a mathematical function. The typical construction is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">formula</span></tt> is a string containing the mathematical expression.
This formula is written with C++ syntax (the expression is
automatically turned into an efficient, compiled C++ function, see the
section <a class="reference internal" href="misc.html#tut-app-cpp-functions"><em>User-Defined Functions</em></a> for details on the syntax). The
independent variables in the function expression are supposed to be
available as a point vector <tt class="docutils literal"><span class="pre">x</span></tt>, where the first element <tt class="docutils literal"><span class="pre">x[0]</span></tt>
corresponds to the <span class="math">\(x\)</span> coordinate, the second element <tt class="docutils literal"><span class="pre">x[1]</span></tt>
to the <span class="math">\(y\)</span> coordinate, and (in a three-dimensional problem)
<tt class="docutils literal"><span class="pre">x[2]</span></tt> to the <span class="math">\(z\)</span> coordinate. With our choice of
<span class="math">\(u_0(x,y)=1 + x^2 + 2y^2\)</span>, the formula string must be written as
<tt class="docutils literal"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">x[0]*x[0]</span> <span class="pre">+</span> <span class="pre">2*x[1]*x[1]</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The information about where to apply the <tt class="docutils literal"><span class="pre">u0</span></tt> function as boundary
condition is coded in a function <tt class="docutils literal"><span class="pre">u0_boundary</span></tt>:</p>
<div class="highlight-python" id="index-17"><div class="highlight"><pre><span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>
</pre></div>
</div>
<p>A function like <tt class="docutils literal"><span class="pre">u0_boundary</span></tt> for marking the boundary must return a
boolean value: <tt class="docutils literal"><span class="pre">True</span></tt> if the given point <tt class="docutils literal"><span class="pre">x</span></tt> lies on the Dirichlet
boundary and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.  The argument <tt class="docutils literal"><span class="pre">on_boundary</span></tt> is
<tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">x</span></tt> is on the physical boundary of the mesh, so in the
present case, where we are supposed to return <tt class="docutils literal"><span class="pre">True</span></tt> for all points
on the boundary, we can just return the supplied value of
<tt class="docutils literal"><span class="pre">on_boundary</span></tt>.  The <tt class="docutils literal"><span class="pre">u0_boundary</span></tt> function will be called for
every discrete point in the mesh, which allows us to have boundaries
where <span class="math">\(u\)</span> are known also inside the domain, if desired.</p>
<p>One can also omit the <tt class="docutils literal"><span class="pre">on_boundary</span></tt> argument, but in that case we
need to test on the value of the coordinates in <tt class="docutils literal"><span class="pre">x</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>As for the formula in <tt class="docutils literal"><span class="pre">Expression</span></tt> objects, <tt class="docutils literal"><span class="pre">x</span></tt> in the
<tt class="docutils literal"><span class="pre">u0_boundary</span></tt> function represents a point in space with coordinates
<tt class="docutils literal"><span class="pre">x[0]</span></tt>, <tt class="docutils literal"><span class="pre">x[1]</span></tt>, etc. Comparing floating-point values using an
exact match test with <tt class="docutils literal"><span class="pre">==</span></tt> is not good programming practice, because
small round-off errors in the computations of the <tt class="docutils literal"><span class="pre">x</span></tt> values could
make a test <tt class="docutils literal"><span class="pre">x[0]</span> <span class="pre">==</span> <span class="pre">1</span></tt> become false even though <tt class="docutils literal"><span class="pre">x</span></tt> lies on the
boundary.  A better test is to check for equality with a tolerance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-15</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> \
           <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> \
           <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> \
           <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p id="index-18">Before defining <span class="math">\(a(u,v)\)</span> and <span class="math">\(L(v)\)</span> we have to specify the
<span class="math">\(f\)</span> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-6&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>When <span class="math">\(f\)</span> is constant over the domain, <tt class="docutils literal"><span class="pre">f</span></tt> can be more
efficiently represented as a <tt class="docutils literal"><span class="pre">Constant</span></tt> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we have all the objects we need in order to specify this problem&#8217;s
<span class="math">\(a(u,v)\)</span> and <span class="math">\(L(v)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>In essence, these two lines specify the PDE to be solved.  Note the
very close correspondence between the Python syntax and the
mathematical formulas <span class="math">\(\nabla u\cdot\nabla v \, \mathrm{d}x\)</span> and
<span class="math">\(fv \, \mathrm{d}x\)</span>.  This is a key strength of FEniCS: the
formulas in the variational formulation translate directly to very
similar Python code, a feature that makes it easy to specify PDE
problems with lots of PDEs and complicated terms in the equations.
The language used to express weak forms is called UFL (Unified Form
Language) and is an integral part of FEniCS.</p>
<p>Instead of <tt class="docutils literal"><span class="pre">nabla_grad</span></tt> we could also just have written <tt class="docutils literal"><span class="pre">grad</span></tt> in
the examples in this tutorial. However, when taking gradients of
vector fields, <tt class="docutils literal"><span class="pre">grad</span></tt> and <tt class="docutils literal"><span class="pre">nabla_grad</span></tt> differ. The latter is
consistent with the tensor algebra commonly used to derive vector and
tensor PDEs, where the &#8220;nabla&#8221; acts as a vector operator, and
therefore this author prefers to always use <tt class="docutils literal"><span class="pre">nabla_grad</span></tt>.</p>
<p>Having <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">L</span></tt> defined, and information about essential
(Dirichlet) boundary conditions in <tt class="docutils literal"><span class="pre">bc</span></tt>, we can compute the
solution, a finite element function <tt class="docutils literal"><span class="pre">u</span></tt>, by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
</pre></div>
</div>
<p>Some prefer to replace <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">L</span></tt> by an <tt class="docutils literal"><span class="pre">equation</span></tt>
variable, which is accomplished by this equivalent code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">equation</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">==</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">equation</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we first defined the variable <tt class="docutils literal"><span class="pre">u</span></tt> as a <tt class="docutils literal"><span class="pre">TrialFunction</span></tt>
and used it to represent the unknown in the form <tt class="docutils literal"><span class="pre">a</span></tt>.  Thereafter,
we redefined <tt class="docutils literal"><span class="pre">u</span></tt> to be a <tt class="docutils literal"><span class="pre">Function</span></tt> object representing the
solution, i.e., the computed finite element function <span class="math">\(u\)</span>.  This
redefinition of the variable <tt class="docutils literal"><span class="pre">u</span></tt> is possible in Python and often
done in FEniCS applications. The two types of objects that <tt class="docutils literal"><span class="pre">u</span></tt>
refers to are equal from a mathematical point of view, and hence it is
natural to use the same variable name for both objects. In a program,
however, <tt class="docutils literal"><span class="pre">TrialFunction</span></tt> objects must always be used for the
unknowns in the problem specification (the form <tt class="docutils literal"><span class="pre">a</span></tt>), while
<tt class="docutils literal"><span class="pre">Function</span></tt> objects must be used for quantities that are computed
(known).</p>
<p>The simplest way of quickly looking at <tt class="docutils literal"><span class="pre">u</span></tt> and the mesh is to say</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">interactive()</span></tt> call is necessary for the plot to remain on the
screen. With the left, middle, and right mouse buttons you can rotate,
translate, and zoom (respectively) the plotted surface to better
examine what the solution looks like.  Figures
<a class="reference internal" href="#tut-poisson-2d-fig-ex1-u"><em>Plot of the solution in the first FEniCS example</em></a> and <a class="reference internal" href="#tut-poisson-2d-fig-ex1-mesh"><em>Plot of the mesh in the first FEniCS example</em></a>
display the resulting <span class="math">\(u\)</span> function and the finite element mesh,
respectively.</p>
<p>It is also possible to dump the computed solution to file, e.g., in
the VTK format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&#39;poisson.pvd&#39;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">poisson.pvd</span></tt> file can now be loaded into any front-end to VTK,
say ParaView or VisIt. The <tt class="docutils literal"><span class="pre">plot</span></tt> function is intended for quick
examination of the solution during program development.  More in-depth
visual investigations of finite element solutions will normally
benefit from using highly professional tools such as ParaView and
VisIt.</p>
<div class="figure" id="tut-poisson-2d-fig-ex1-u">
<a class="reference internal image-reference" href="../../_images/ex1_u.png"><img alt="../../_images/ex1_u.png" src="../../_images/ex1_u.png" style="width: 480px;" /></a>
<p class="caption">Plot of the solution in the first FEniCS example</p>
</div>
<div class="figure" id="tut-poisson-2d-fig-ex1-mesh">
<a class="reference internal image-reference" href="../../_images/ex1_mesh.png"><img alt="../../_images/ex1_mesh.png" src="../../_images/ex1_mesh.png" style="width: 480px;" /></a>
<p class="caption">Plot of the mesh in the first FEniCS example</p>
</div>
<p>The next three sections deal with some technicalities about specifying
the solution method for linear systems (so that you can solve large
problems) and examining array data from the computed solution (so that
you can check that the program is correct).  These technicalities are
scattered around in forthcoming programs. However, the impatient
reader who is more interested in seeing the previous program being
adapted to a real physical problem, and play around with some
interesting visualizations, can safely jump to the section
<a class="reference internal" href="#tut-poisson-membrane"><em>Solving a Real Physical Problem</em></a>.  Information in the intermediate sections
can be studied on demand.</p>
</div>
<div class="section" id="controlling-the-solution-process">
<span id="tut-poisson1-solve-prm"></span><h2>Controlling the Solution Process<a class="headerlink" href="#controlling-the-solution-process" title="Permalink to this headline">¶</a></h2>
<p>Sparse LU decomposition (Gaussian elimination) is used by default to
solve linear systems of equations in FEniCS programs.  This is a very
robust and recommended method for a few thousand unknowns in the
equation system, and may hence be the method of choice in many 2D and
smaller 3D problems. However, sparse LU decomposition becomes slow and
memory demanding in large problems.  This fact forces the use of
iterative methods, which are faster and require much less memory.</p>
<p id="index-19">Preconditioned Krylov solvers is a type of popular iterative methods
that are easily accessible in FEniCS programs. The Poisson equation
results in a symmetric, positive definite coefficient matrix, for
which the optimal Krylov solver is the Conjugate Gradient (CG)
method. Incomplete LU factorization (ILU) is a popular and robust
all-round preconditioner, so let us try the CG&#8211;ILU pair:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
      <span class="n">solver_parameters</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;cg&#39;</span><span class="p">,</span>
                         <span class="s">&#39;preconditioner&#39;</span><span class="p">:</span> <span class="s">&#39;ilu&#39;</span><span class="p">})</span>
<span class="c"># Alternative syntax</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span>
      <span class="n">solver_parameters</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;cg&#39;</span><span class="p">,</span>
                             <span class="n">preconditioner</span><span class="o">=</span><span class="s">&#39;ilu&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>the section <a class="reference internal" href="misc.html#tut-app-solver-prec"><em>Linear Solvers and Preconditioners</em></a> lists the most popular choices
of Krylov solvers and preconditioners available in FEniCS</p>
<span class="target" id="index-20"></span><span class="target" id="index-21"></span><span class="target" id="index-22"></span><span class="target" id="index-23"></span><p id="index-24">The actual CG and ILU implementations that are brought into action
depends on the choice of linear algebra package. FEniCS interfaces
several linear algebra packages, called <em>linear algebra backends</em> in
FEniCS terminology.  PETSc is the default choice if DOLFIN is compiled
with PETSc, otherwise uBLAS.  Epetra (Trilinos) and MTL4 are two other
supported backends.  Which backend to apply can be controlled by
setting</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_algebra_backend&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">backendname</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">backendname</span></tt> is a string, either <tt class="docutils literal"><span class="pre">'PETSc'</span></tt>, <tt class="docutils literal"><span class="pre">'uBLAS'</span></tt>,
<tt class="docutils literal"><span class="pre">'Epetra'</span></tt>, or <tt class="docutils literal"><span class="pre">'MTL4'</span></tt>.  All these backends offer high-quality
implementations of both iterative and direct solvers for linear
systems of equations.</p>
<p id="index-25">A common platform for FEniCS users is Ubuntu Linux.  The FEniCS
distribution for Ubuntu contains PETSc, making this package the
default linear algebra backend.  The default solver is sparse LU
decomposition (<tt class="docutils literal"><span class="pre">'lu'</span></tt>), and the actual software that is called is
then the sparse LU solver from UMFPACK (which PETSc has an interface
to).</p>
<span class="target" id="index-26"></span><p id="index-27">We will normally like to control the tolerance in the stopping
criterion and the maximum number of iterations when running an
iterative method.  Such parameters can be set by accessing the <em>global
parameter database</em>, which is called <tt class="docutils literal"><span class="pre">parameters</span></tt> and which behaves
as a nested dictionary. Write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">info</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>to list all parameters and their default values in the database.
The nesting of parameter sets is indicated through indentation in the
output from <tt class="docutils literal"><span class="pre">info</span></tt>.
According to this output, the relevant parameter set is
named <tt class="docutils literal"><span class="pre">'krylov_solver'</span></tt>, and the parameters are set like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">prm</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">]</span> <span class="c"># short form</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-10</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-6</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
</pre></div>
</div>
<p>Stopping criteria for Krylov solvers usually involve the norm of the
residual, which must be smaller than the absolute tolerance parameter
and smaller than the relative tolerance parameter times the initial
residual.</p>
<p>To see the number of actual iterations to reach the stopping
criterion, we can insert</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">set_log_level</span><span class="p">(</span><span class="n">PROGRESS</span><span class="p">)</span>
<span class="c"># or</span>
<span class="n">set_log_level</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span>
</pre></div>
</div>
<p>A message with the equation system size, solver type, and number of
iterations arises from specifying the argument <tt class="docutils literal"><span class="pre">PROGRESS</span></tt>, while
<tt class="docutils literal"><span class="pre">DEBUG</span></tt> results in more information, including CPU time spent in the
various parts of the matrix assembly and solve process.</p>
<p>The complete solution process with control of the solver parameters
now contains the statements</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">prm</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">]</span> <span class="c"># short form</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-10</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-6</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">set_log_level</span><span class="p">(</span><span class="n">PROGRESS</span><span class="p">)</span>

<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span>
      <span class="n">solver_parameters</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;cg&#39;</span><span class="p">,</span>
                         <span class="s">&#39;preconditioner&#39;</span><span class="p">:</span> <span class="s">&#39;ilu&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>The demo program <tt class="docutils literal"><span class="pre">d2_p2D.py</span></tt> in the <tt class="docutils literal"><span class="pre">stationary/poisson</span></tt> directory
incorporates the above shown control of the linear solver and
precnditioner, but is otherwise similar to the previous <tt class="docutils literal"><span class="pre">d1_p2D.py</span></tt>
program.</p>
<p>We remark that default values for the global parameter database can be
defined in an XML file, see the example file <tt class="docutils literal"><span class="pre">dolfin_parameters.xml</span></tt>
in the directory <tt class="docutils literal"><span class="pre">stationary/poisson</span></tt>.  If such a file is found in
the directory where a FEniCS program is run, this file is read and
used to initialize the <tt class="docutils literal"><span class="pre">parameters</span></tt> object. Otherwise, the file
<tt class="docutils literal"><span class="pre">.config/fenics/dolfin_parameters.xml</span></tt> in the user&#8217;s home directory
is read, if it exists.  The XML file can also be in gzip&#8217;ed form with
the extension <tt class="docutils literal"><span class="pre">.xml.gz</span></tt>.</p>
</div>
<div class="section" id="linear-variational-problem-and-solver-objects">
<span id="tut-poisson1-solver-problem"></span><h2>Linear Variational Problem and Solver Objects<a class="headerlink" href="#linear-variational-problem-and-solver-objects" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-28"></span><span class="target" id="index-29"></span><p id="index-30">The <tt class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">bc)</span></tt> call is just a compact syntax alternative
to a slightly more comprehensive specification of the variational
equation and the solution of the associated linear system.  This
alternative syntax is used in a lot of FEniCS applications and will
also be used later in this tutorial, so we show it already now:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
<span class="n">solver</span>  <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>Many objects have an attribute <tt class="docutils literal"><span class="pre">parameters</span></tt> corresponding to a
parameter set in the global <tt class="docutils literal"><span class="pre">parameters</span></tt> database, but local to the
object. Here, <tt class="docutils literal"><span class="pre">solver.parameters</span></tt> play that role. Setting the CG
method with ILU preconditiong as solution method and specifying
solver-specific parameters can be done like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_solver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;cg&#39;</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;preconditioner&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ilu&#39;</span>
<span class="n">cg_prm</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">]</span> <span class="c"># short form</span>
<span class="n">cg_prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-7</span>
<span class="n">cg_prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-4</span>
<span class="n">cg_prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
</pre></div>
</div>
<p>Calling <tt class="docutils literal"><span class="pre">info(solver.parameters,</span> <span class="pre">True)</span></tt> lists all the available
parameter sets with default values for each parameter.  Settings in
the global <tt class="docutils literal"><span class="pre">parameters</span></tt> database are propagated to parameter sets in
individual objects, with the possibility of being overwritten as done
above.</p>
<p>The <tt class="docutils literal"><span class="pre">d3_p2D.py</span></tt> program modifies the <tt class="docutils literal"><span class="pre">d2_p2D.py</span></tt> file to
incorporate objects for the variational problem and solver.</p>
</div>
<div class="section" id="examining-the-discrete-solution">
<span id="tut-poisson1-verify1"></span><h2>Examining the Discrete Solution<a class="headerlink" href="#examining-the-discrete-solution" title="Permalink to this headline">¶</a></h2>
<p id="index-31">We know that, in the particular boundary-value problem of the section
<a class="reference internal" href="#tut-poisson1-impl"><em>Implementation (1)</em></a>, the computed solution <span class="math">\(u\)</span> should equal
the exact solution at the vertices of the cells.  An important
extension of our first program is therefore to examine the computed
values of the solution, which is the focus of the present section.</p>
<p>A finite element function like <span class="math">\(u\)</span> is expressed as a linear
combination of basis functions <span class="math">\(\phi_j\)</span>, spanning the space
<span class="math">\(V\)</span>:</p>
<div class="math" id="equation-tut:poisson1:ufem">
<span class="eqno">(7)</span>\[     \sum_{j=1}^N U_j \phi_j \thinspace .\]</div>
<p>By writing <tt class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">bc)</span></tt> in the program, a linear system
will be formed from <span class="math">\(a\)</span> and <span class="math">\(L\)</span>, and this system is solved
for the <span class="math">\(U_1,\ldots,U_N\)</span> values. The <span class="math">\(U_1,\ldots,U_N\)</span>
values are known</p>
<p id="index-32">as <em>degrees of freedom</em> of <span class="math">\(u\)</span>. For Lagrange elements (and many
other element types) <span class="math">\(U_k\)</span> is simply the value of <span class="math">\(u\)</span> at
the node with global number <span class="math">\(k\)</span>.  (The nodes and cell vertices
coincide for linear Lagrange elements, while for higher-order elements
there may be additional nodes at the facets and in the interior of
cells.)</p>
<p>Having <tt class="docutils literal"><span class="pre">u</span></tt> represented as a <tt class="docutils literal"><span class="pre">Function</span></tt> object, we can either
evaluate <tt class="docutils literal"><span class="pre">u(x)</span></tt> at any vertex <tt class="docutils literal"><span class="pre">x</span></tt> in the mesh, or we can grab all
the values <span class="math">\(U_j\)</span> directly by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_nodal_values</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
</pre></div>
</div>
<p>The result is a DOLFIN <tt class="docutils literal"><span class="pre">Vector</span></tt> object, which is basically an
encapsulation of the vector object used in the linear algebra package
that is used to solve the linear system arising from the variational
problem.  Since we program in Python it is convenient to convert the
<tt class="docutils literal"><span class="pre">Vector</span></tt> object to a standard <tt class="docutils literal"><span class="pre">numpy</span></tt> array for further
processing:</p>
<span class="target" id="index-33"></span><div class="highlight-python" id="index-34"><div class="highlight"><pre><span class="n">u_array</span> <span class="o">=</span> <span class="n">u_nodal_values</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>With <tt class="docutils literal"><span class="pre">numpy</span></tt> arrays we can write &#8220;MATLAB-like&#8221; code to analyze the
data. Indexing is done with square brackets: <tt class="docutils literal"><span class="pre">u_array[i]</span></tt>, where the
index <tt class="docutils literal"><span class="pre">i</span></tt> always starts at <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
<dl class="docutils">
<dt>Mesh information can be gathered from the emp{mesh} object, e.g.,</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">mesh.coordinates()</span></tt> returns the coordinates of the vertices as
an <span class="math">\(M\times d\)</span> <tt class="docutils literal"><span class="pre">numpy</span></tt> array, <span class="math">\(M\)</span> being the number
of vertices in the mesh and <span class="math">\(d\)</span> being the number of space
dimensions,</li>
<li><tt class="docutils literal"><span class="pre">mesh.num_cells()</span></tt> returns the number of cells (triangles) in
the mesh,</li>
<li><tt class="docutils literal"><span class="pre">mesh.num_vertices()</span></tt> returns the number of vertices in the mesh
(with our choice of linear Lagrange elements this equals the
number of nodes),</li>
</ul>
</dd>
</dl>
<p>Writing <tt class="docutils literal"><span class="pre">print</span> <span class="pre">mesh</span></tt> dumps a short, &#8220;pretty print&#8221; description of
the mesh (<tt class="docutils literal"><span class="pre">print</span> <span class="pre">mesh</span></tt> actually displays the result of str(mesh)`,
which defines the pretty print):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="o">&lt;</span><span class="n">Mesh</span> <span class="n">of</span> <span class="n">topological</span> <span class="n">dimension</span> <span class="mi">2</span> <span class="p">(</span><span class="n">triangles</span><span class="p">)</span> <span class="k">with</span>
<span class="mi">16</span> <span class="n">vertices</span> <span class="ow">and</span> <span class="mi">18</span> <span class="n">cells</span><span class="p">,</span> <span class="n">ordered</span><span class="o">&gt;</span>
</pre></div>
</div>
<p id="index-35">All mesh objects are of type <tt class="docutils literal"><span class="pre">Mesh</span></tt> so typing the command <tt class="docutils literal"><span class="pre">pydoc</span>
<span class="pre">dolfin.Mesh</span></tt> in a terminal window will give a list of methods (that
is, functions in a class) that can be called through any <tt class="docutils literal"><span class="pre">Mesh</span></tt>
object. In fact, <tt class="docutils literal"><span class="pre">pydoc</span> <span class="pre">dolfin.X</span></tt> shows the documentation of any
DOLFIN name <tt class="docutils literal"><span class="pre">X</span></tt>.</p>
<p>Writing out the solution on the screen can now be done by a simple
loop:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">coor</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
<span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">u_array</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()):</span>
        <span class="k">print</span> <span class="s">&#39;u(</span><span class="si">%8g</span><span class="s">,</span><span class="si">%8g</span><span class="s">) = </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">coor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">u_array</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>The beginning of the output looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">(</span>       <span class="mi">0</span><span class="p">,</span>       <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">u</span><span class="p">(</span><span class="mf">0.166667</span><span class="p">,</span>       <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.02778</span>
<span class="n">u</span><span class="p">(</span><span class="mf">0.333333</span><span class="p">,</span>       <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.11111</span>
<span class="n">u</span><span class="p">(</span>     <span class="mf">0.5</span><span class="p">,</span>       <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.25</span>
<span class="n">u</span><span class="p">(</span><span class="mf">0.666667</span><span class="p">,</span>       <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.44444</span>
<span class="n">u</span><span class="p">(</span><span class="mf">0.833333</span><span class="p">,</span>       <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.69444</span>
<span class="n">u</span><span class="p">(</span>       <span class="mi">1</span><span class="p">,</span>       <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>For Lagrange elements of degree higher than one, the vertices do not
correspond to all the nodal points and the <cite>if</cite>-test fails.</p>
<p>For verification purposes we want to compare the values of the
computed <tt class="docutils literal"><span class="pre">u</span></tt> at the nodes (given by <tt class="docutils literal"><span class="pre">u_array</span></tt>) with the exact
solution <tt class="docutils literal"><span class="pre">u0</span></tt> evaluated at the nodes.  The difference between the
computed and exact solution should be less than a small tolerance at
all the nodes. The <tt class="docutils literal"><span class="pre">Expression</span></tt> object <tt class="docutils literal"><span class="pre">u0</span></tt> can be evaluated at
any point <tt class="docutils literal"><span class="pre">x</span></tt> by calling <tt class="docutils literal"><span class="pre">u0(x)</span></tt>. Specifically, <tt class="docutils literal"><span class="pre">u0(coor[i])</span></tt>
returns the value of <tt class="docutils literal"><span class="pre">u0</span></tt> at the vertex or node with global number
<tt class="docutils literal"><span class="pre">i</span></tt>.</p>
<span class="target" id="index-36"></span><p id="index-37">Alternatively, we can make a finite element field <tt class="docutils literal"><span class="pre">u_e</span></tt>,
representing the exact solution, whose values at the nodes are given
by the <tt class="docutils literal"><span class="pre">u0</span></tt> function. With mathematics, <span class="math">\(u_{\mbox{e}} =
\sum_{j=1}^N E_j\phi_j\)</span>, where <span class="math">\(E_j=u_0(x_j,y_j)\)</span>,
<span class="math">\((x_j,y_j)\)</span> being the coordinates of node number <span class="math">\(j\)</span>.
This process is known as interpolation.  FEniCS has a function for
performing the operation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>The maximum error can now be computed as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_e_array</span> <span class="o">=</span> <span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;Max error:&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e_array</span> <span class="o">-</span> <span class="n">u_array</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</div>
<p>The value of the error should be at the level of the machine precision
(<span class="math">\(10^{-16}\)</span>).</p>
<p>To demonstrate the use of point evaluations of <tt class="docutils literal"><span class="pre">Function</span></tt> objects,
we write out the computed <tt class="docutils literal"><span class="pre">u</span></tt> at the center point of the domain and
compare it with the exact solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;numerical u at the center point:&#39;</span><span class="p">,</span>  <span class="n">u</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;exact     u at the center point:&#39;</span><span class="p">,</span> <span class="n">u0</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
</pre></div>
</div>
<p>Trying a <span class="math">\(3\times 3\)</span> mesh, the output from the previous snippet
becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">numerical</span> <span class="n">u</span> <span class="n">at</span> <span class="n">the</span> <span class="n">center</span> <span class="n">point</span><span class="p">:</span> <span class="p">[</span> <span class="mf">1.83333333</span><span class="p">]</span>
<span class="n">exact</span>     <span class="n">u</span> <span class="n">at</span> <span class="n">the</span> <span class="n">center</span> <span class="n">point</span><span class="p">:</span> <span class="p">[</span> <span class="mf">1.75</span><span class="p">]</span>
</pre></div>
</div>
<p>The discrepancy is due to the fact that the center point is not a node
in this particular mesh, but a point in the interior of a cell, and
<tt class="docutils literal"><span class="pre">u</span></tt> varies linearly over the cell while <tt class="docutils literal"><span class="pre">u0</span></tt> is a quadratic
function.</p>
<p>We have seen how to extract the nodal values in a <tt class="docutils literal"><span class="pre">numpy</span></tt> array.  If
desired, we can adjust the nodal values too. Say we want to normalize
the solution such that <span class="math">\(\max_j U_j = 1\)</span>. Then we must divide all
<span class="math">\(U_j\)</span> values by <span class="math">\(\max_j U_j\)</span>. The following snippet
performs the task:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">max_u</span> <span class="o">=</span> <span class="n">u_array</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">u_array</span> <span class="o">/=</span> <span class="n">max_u</span>
<span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u_array</span>
<span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">set_local</span><span class="p">(</span><span class="n">u_array</span><span class="p">)</span>  <span class="c"># alternative</span>
<span class="k">print</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>That is, we manipulate <tt class="docutils literal"><span class="pre">u_array</span></tt> as desired, and then we insert this
array into <cite>u</cite>&#8216;s <tt class="docutils literal"><span class="pre">Vector</span></tt> object.  The <tt class="docutils literal"><span class="pre">/=</span></tt> operator implies an
in-place modification of the object on the left-hand side: all
elements of the <tt class="docutils literal"><span class="pre">u_array</span></tt> are divided by the value <tt class="docutils literal"><span class="pre">max_u</span></tt>.
Alternatively, one could write <tt class="docutils literal"><span class="pre">u_array</span> <span class="pre">=</span> <span class="pre">u_array/max_u</span></tt>, which
implies creating a new array on the right-hand side and assigning this
array to the name <tt class="docutils literal"><span class="pre">u_array</span></tt>.</p>
<p>A call like <tt class="docutils literal"><span class="pre">u.vector().array()</span></tt> returns a copy of the data in
<tt class="docutils literal"><span class="pre">u.vector()</span></tt>. One must therefore never perform assignments like
<tt class="docutils literal"><span class="pre">u.vector.array()[:]</span> <span class="pre">=</span> <span class="pre">...</span></tt>, but instead extract the <tt class="docutils literal"><span class="pre">numpy</span></tt> array
(i.e., a copy), manipulate it, and insert it back with <tt class="docutils literal"><span class="pre">u.vector()[:]</span>
<span class="pre">=</span> <span class="pre">``</span> <span class="pre">or</span> <span class="pre">``u.set_local(...)</span></tt>.</p>
<p>All the code in this subsection can be found in the file <tt class="docutils literal"><span class="pre">d4_p2D.py</span></tt>
in the <tt class="docutils literal"><span class="pre">stationary/poisson</span></tt> directory.  We have commented out the
plotting statements in this version of the program, but if you want
plotting to happen, make sure that <tt class="docutils literal"><span class="pre">interactive</span></tt> is called at the
very end of the program.</p>
</div>
<div class="section" id="solving-a-real-physical-problem">
<span id="tut-poisson-membrane"></span><h2>Solving a Real Physical Problem<a class="headerlink" href="#solving-a-real-physical-problem" title="Permalink to this headline">¶</a></h2>
<p>Perhaps you are not particularly amazed by viewing the simple surface
of <span class="math">\(u\)</span> in the test problem from the section
<a class="reference internal" href="#tut-poisson1-impl"><em>Implementation (1)</em></a>.  However, solving a real physical problem
with a more interesting and amazing solution on the screen is only a
matter of specifying a more exciting domain, boundary condition,
and/or right-hand side <span class="math">\(f\)</span>.</p>
<p>One possible physical problem regards the deflection <span class="math">\(D(x,y)\)</span> of
an elastic circular membrane with radius <span class="math">\(R\)</span>, subject to a
localized perpendicular pressure force, modeled as a Gaussian
function.  The appropriate PDE model is</p>
<div class="math">
\[-T\nabla^2 D = p(x,y)\quad\hbox{in }\Omega = \{ (x,y)\,|\, x^2+y^2\leq R\},\]</div>
<p>with</p>
<div class="math">
\[p(x,y) = {A\over 2\pi\sigma}\exp{\left(
- {1\over2}\left( {x-x_0\over\sigma}\right)^2
- {1\over2}\left( {y-y_0\over\sigma}\right)^2
\right)}\, .\]</div>
<p>Here, <span class="math">\(T\)</span> is the tension in the membrane (constant), <span class="math">\(p\)</span>
is the external pressure load, <span class="math">\(A\)</span> the amplitude of the
pressure, <span class="math">\((x_0,y_0)\)</span> the localization of the Gaussian pressure
function, and <span class="math">\(\sigma\)</span> the &#8220;width&#8221; of this function. The
boundary of the membrane has no deflection, implying <span class="math">\(D=0\)</span> as
boundary condition.</p>
<p>For scaling and verification it is convenient to simplify the problem
to find an analytical solution. In the limit
<span class="math">\(\sigma\rightarrow\infty\)</span>, <span class="math">\(p\rightarrow A/(2\pi\sigma)\)</span>,
which allows us to integrate an axi&#8211;symmetric version of the equation
in the radial coordinate <span class="math">\(r\in [0,R]\)</span> and obtain
<span class="math">\(D(r)=(r^2-R^2)A/(8\pi\sigma T)\)</span>. This result gives a rough
estimate of the characteristic size of the deflection:
<span class="math">\(|D(0)|=AR^2/(8\pi\sigma T)\)</span>, which can be used to scale the
deflecton.  With <span class="math">\(R\)</span> as characteristic length scale, we can
derive the equivalent dimensionless problem on the unit circle,</p>
<div class="math" id="equation-tut:poisson1:membrane:scaled:eq">
<span class="eqno">(8)</span>\[     -\nabla^2 w = f,\]</div>
<p>with <span class="math">\(w=0\)</span> on the boundary and with</p>
<div class="math" id="equation-tut:poisson1:membrane:scaled:eq:rhs">
<span class="eqno">(9)</span>\[     f(x,y) = 4\exp{\left(
     - \frac{1}{2}\left( \frac{Rx-x_0}{\sigma}\right)^2
     - \frac{1}{2}\left( \frac{Ry-y_0}{\sigma}\right)^2
     \right)}.\]</div>
<p>end{equation}
For notational convenience we have dropped introducing
new symbols for the scaled coordinates in
<a href="#equation-tut:poisson1:membrane:scaled:eq:rhs">(9)</a>.  Now <span class="math">\(D\)</span> is related
to <span class="math">\(w\)</span> through <span class="math">\(D = AR^2w/(8\pi\sigma T)\)</span>.</p>
<p>Let us list the modifications of the <tt class="docutils literal"><span class="pre">d1_p2D.py</span></tt> program that are
needed to solve this membrane problem:</p>
<blockquote>
<div><ul class="simple">
<li>Initialize <span class="math">\(T\)</span>, <span class="math">\(A\)</span>, <span class="math">\(R\)</span>, <span class="math">\(x_0\)</span>,
<span class="math">\(y_0\)</span>, and <span class="math">\(\sigma\)</span>,</li>
<li>create a mesh over the unit circle,</li>
<li>make an expression object for the scaled pressure function
<span class="math">\(f\)</span>,</li>
<li>define the <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">L</span></tt> formulas in the variational problem for
<span class="math">\(w\)</span> and compute the solution,</li>
<li>plot the mesh, <span class="math">\(w\)</span>, and <span class="math">\(f\)</span>,</li>
<li>write out the maximum real deflection <span class="math">\(D\)</span>.</li>
</ul>
</div></blockquote>
<p>Some suitable values of <span class="math">\(T\)</span>, <span class="math">\(A\)</span>, <span class="math">\(R\)</span>, <span class="math">\(x_0\)</span>,
<span class="math">\(y_0\)</span>, and <span class="math">\(\sigma\)</span> are</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">T</span> <span class="o">=</span> <span class="mf">10.0</span>  <span class="c"># tension</span>
<span class="n">A</span> <span class="o">=</span> <span class="mf">1.0</span>   <span class="c"># pressure amplitude</span>
<span class="n">R</span> <span class="o">=</span> <span class="mf">0.3</span>   <span class="c"># radius of domain</span>
<span class="n">theta</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">x0</span> <span class="o">=</span> <span class="mf">0.6</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">y0</span> <span class="o">=</span> <span class="mf">0.6</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.025</span>
</pre></div>
</div>
<p>A mesh over the unit circle can be created by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitCircle</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">n</span></tt> is the typical number of elements in the radial direction.</p>
<span class="target" id="index-38"></span><p id="index-39">The function <span class="math">\(f\)</span> is represented by an <tt class="docutils literal"><span class="pre">Expression</span></tt>
object. There are many physical parameters in the formula for
<span class="math">\(f\)</span> that enter the expression string and these parameters must
have their values set by keyword arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;4*exp(-0.5*(pow((R*x[0] - x0)/sigma, 2)) &#39;</span>
               <span class="s">&#39;     - 0.5*(pow((R*x[1] - y0)/sigma, 2)))&#39;</span><span class="p">,</span>
               <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="n">y0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
</pre></div>
</div>
<p>The coordinates in <tt class="docutils literal"><span class="pre">Expression</span></tt> objects <em>must</em> be a vector with
indices 0, 1, and 2, and with the name <tt class="docutils literal"><span class="pre">x</span></tt>. Otherwise we are free to
introduce names of parameters as long as these are given default
values by keyword arguments. All the parameters initialized by keyword
arguments can at any time have their values modified. For example, we
may set</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">f</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="mf">0.3</span>
</pre></div>
</div>
<p id="index-40">It would be of interest to visualize <span class="math">\(f\)</span> along with <span class="math">\(w\)</span> so
that we can examine the pressure force and its response.  We must then
transform the formula (<tt class="docutils literal"><span class="pre">Expression</span></tt>) to a finite element function
(<tt class="docutils literal"><span class="pre">Function</span></tt>).  The most natural approach is to construct a finite
element function whose degrees of freedom (values at the nodes in this
case) are calculated from <span class="math">\(f\)</span>. That is, we interpolate <span class="math">\(f\)</span>
(see the section <a class="reference internal" href="#tut-poisson1-verify1"><em>Examining the Discrete Solution</em></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>Calling <tt class="docutils literal"><span class="pre">plot(f)</span></tt> will produce a plot of <span class="math">\(f\)</span>. Note that the
assignment to <tt class="docutils literal"><span class="pre">f</span></tt> destroys the previous <tt class="docutils literal"><span class="pre">Expression</span></tt> object <tt class="docutils literal"><span class="pre">f</span></tt>,
so if it is of interest to still have access to this object, another
name must be used for the <tt class="docutils literal"><span class="pre">Function</span></tt> object returned by
<tt class="docutils literal"><span class="pre">interpolate</span></tt>.</p>
<p>We need some evidence that the program works, and to this end we may
use the analytical solution listed above for the case
<span class="math">\(\sigma\rightarrow\infty\)</span>. In scaled coordinates the solution
reads</p>
<div class="math">
\[w_{\rm}(x,y) = 1-x^2-y^2 .\]</div>
<p>Practical values for an infinite <span class="math">\(\sigma\)</span> may be 50 or larger,
and in such cases the program will report the maximum deviation
between the computed <span class="math">\(w\)</span> and the (approximate) exact
<span class="math">\(w_{\rm e}\)</span>.</p>
<p id="index-41">Note that the variational formulation remains the same as in the
program from the section <a class="reference internal" href="#tut-poisson1-impl"><em>Implementation (1)</em></a>, except that
<span class="math">\(u\)</span> is replaced by <span class="math">\(w\)</span> and <span class="math">\(u_0=0\)</span>.  The final
program is found in the file <tt class="docutils literal"><span class="pre">membrane1.py</span></tt>, located in the
<tt class="docutils literal"><span class="pre">stationary/poisson</span></tt> directory, and also listed below.  We have
inserted capabilities for iterative solution methods and hence large
meshes (the section <a class="reference internal" href="#tut-poisson1-solve-prm"><em>Controlling the Solution Process</em></a>), used objects for
the variational problem and solver (the section
<a class="reference internal" href="#tut-poisson1-solver-problem"><em>Linear Variational Problem and Solver Objects</em></a>), and made numerical comparison of
the numerical and (approximate) analytical solution (the section
<a class="reference internal" href="#tut-poisson1-verify1"><em>Examining the Discrete Solution</em></a>).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">FEniCS program for the deflection w(x,y) of a membrane:</span>
<span class="sd">-Laplace(w) = p = Gaussian function, in a unit circle,</span>
<span class="sd">with w = 0 on the boundary.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="c"># Set pressure function:</span>
<span class="n">T</span> <span class="o">=</span> <span class="mf">10.0</span>  <span class="c"># tension</span>
<span class="n">A</span> <span class="o">=</span> <span class="mf">1.0</span>   <span class="c"># pressure amplitude</span>
<span class="n">R</span> <span class="o">=</span> <span class="mf">0.3</span>   <span class="c"># radius of domain</span>
<span class="n">theta</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">x0</span> <span class="o">=</span> <span class="mf">0.6</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">y0</span> <span class="o">=</span> <span class="mf">0.6</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.025</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="mi">50</span>  <span class="c"># large value for verification</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">40</span>   <span class="c"># approx no of elements in radial direction</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitCircle</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c"># Define boundary condition w=0</span>
<span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">boundary</span><span class="p">)</span>

<span class="c"># Define variational problem</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;4*exp(-0.5*(pow((R*x[0] - x0)/sigma, 2)) &#39;</span>
               <span class="s">&#39;      -0.5*(pow((R*x[1] - y0)/sigma, 2)))&#39;</span><span class="p">,</span>
               <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="n">y0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="c"># Compute solution</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
<span class="n">solver</span>  <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_solver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;cg&#39;</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;preconditioner&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ilu&#39;</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

<span class="c"># Plot scaled solution, mesh and pressure</span>
<span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Mesh over scaled domain&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Scaled deflection&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Scaled pressure&#39;</span><span class="p">)</span>

<span class="c"># Find maximum real deflection</span>
<span class="n">max_w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">max_D</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">max_w</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">sigma</span><span class="o">*</span><span class="n">T</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;Maximum real deflection is&#39;</span><span class="p">,</span> <span class="n">max_D</span>

<span class="c"># Verification for &quot;flat&quot; pressure (large sigma)</span>
<span class="k">if</span> <span class="n">sigma</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">:</span>
    <span class="n">w_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&quot;1 - x[0]*x[0] - x[1]*x[1]&quot;</span><span class="p">)</span>
    <span class="n">w_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">w_e</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">dev</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> <span class="n">w</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&#39;sigma=</span><span class="si">%g</span><span class="s">: max deviation=</span><span class="si">%e</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span>

<span class="c"># Should be at the end</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>Choosing a small width <span class="math">\(\sigma\)</span> (say 0.01) and a location
<span class="math">\((x_0,y_0)\)</span> toward the circular boundary (say
<span class="math">\((0.6R\cos\theta, 0.6R\sin\theta)\)</span> for any <span class="math">\(\theta\in
[0,2\pi]\)</span>), may produce an exciting visual comparison of <span class="math">\(w\)</span> and
<span class="math">\(f\)</span> that demonstrates the very smoothed elastic response to a
peak force (or mathematically, the smoothing properties of the inverse
of the Laplace operator).  One needs to experiment with the mesh
resolution to get a smooth visual representation of~$f$.  You are
strongly encouraged to play around with the plots and different mesh
resolutions.</p>
</div>
<div class="section" id="quick-visualization-with-vtk">
<span id="tut-quickviz"></span><h2>Quick Visualization with VTK<a class="headerlink" href="#quick-visualization-with-vtk" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-42"></span><span class="target" id="index-43"></span><p id="index-44">As we go along with examples it is fun to play around with <tt class="docutils literal"><span class="pre">plot</span></tt>
commands and visualize what is computed. This section explains some
useful visualization features.</p>
<p>The <tt class="docutils literal"><span class="pre">plot(u)</span></tt> command launches a FEniCS component called Viper,
which applies the VTK package to visualize finite element functions.
Viper is not a full-fledged, easy-to-use front-end to VTK (like
Mayavi2, ParaView or, VisIt), but rather a thin layer on top of VTK&#8217;s
Python interface, allowing us to quickly visualize a DOLFIN function
or mesh, or data in plain Numerical Python arrays, within a Python
program.  Viper is ideal for debugging, teaching, and initial
scientific investigations.  The visualization can be interactive, or
you can steer and automate it through program statements.  More
advanced and professional visualizations are usually better done with
advanced tools like Mayavi2, ParaView, or VisIt.</p>
<p id="index-45">We have made a program <tt class="docutils literal"><span class="pre">membrane1v.py</span></tt> for the membrane deflection
problem in the section <a class="reference internal" href="#tut-poisson-membrane"><em>Solving a Real Physical Problem</em></a> and added various
demonstrations of Viper capabilities. You are encouraged to play
around with <tt class="docutils literal"><span class="pre">membrane1v.py</span></tt> and modify the code as you read about
various features.</p>
<p id="index-46">The <tt class="docutils literal"><span class="pre">plot</span></tt> function can take additional arguments, such as a title
of the plot, or a specification of a wireframe plot (elevated mesh)
instead of a colored surface plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Finite element mesh&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">wireframe</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;solution&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The three mouse buttons can be used to rotate, translate, and zoom the
surface.  Pressing <tt class="docutils literal"><span class="pre">h</span></tt> in the plot window makes a printout of
several key bindings that are available in such windows. For example,
pressing <tt class="docutils literal"><span class="pre">m</span></tt> in the mesh plot window dumps the plot of the mesh to
an Encapsulated PostScript (<tt class="docutils literal"><span class="pre">.eps</span></tt>) file, while pressing <tt class="docutils literal"><span class="pre">i</span></tt> saves
the plot in PNG format.  All plotfile names are automatically
generated as <tt class="docutils literal"><span class="pre">simulationX.eps</span></tt>, where <tt class="docutils literal"><span class="pre">X</span></tt> is a counter <tt class="docutils literal"><span class="pre">0000</span></tt>,
<tt class="docutils literal"><span class="pre">0001</span></tt>, <tt class="docutils literal"><span class="pre">0002</span></tt>, etc., being increased every time a new plot file
in that format is generated (the extension of PNG files is <tt class="docutils literal"><span class="pre">.png</span></tt>
instead of <tt class="docutils literal"><span class="pre">.eps</span></tt>).  Pressing <tt class="docutils literal"><span class="pre">o</span></tt> adds a red outline of a bounding
box around the domain.</p>
<p>One can alternatively control the visualization from the program code
directly. This is done through a <tt class="docutils literal"><span class="pre">Viper</span></tt> object returned from the
<tt class="docutils literal"><span class="pre">plot</span></tt> command. Let us grab this object and use it to
1) tilt the camera <span class="math">\(-65\)</span> degrees in the latitude direction, 2)
add <span class="math">\(x\)</span> and <span class="math">\(y\)</span> axes, 3) change the default name of the
plot files,
4) change the color scale, and 5) write the plot
to a PNG and an EPS file. Here is the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">viz_w</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span>
            <span class="n">wireframe</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">title</span><span class="o">=</span><span class="s">&#39;Scaled membrane deflection&#39;</span><span class="p">,</span>
            <span class="n">rescale</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>              <span class="c"># include axes</span>
            <span class="n">basename</span><span class="o">=</span><span class="s">&#39;deflection&#39;</span><span class="p">,</span>  <span class="c"># default plotfile name</span>
            <span class="p">)</span>

<span class="n">viz_w</span><span class="o">.</span><span class="n">elevate</span><span class="p">(</span><span class="o">-</span><span class="mi">65</span><span class="p">)</span> <span class="c"># tilt camera -65 degrees (latitude dir)</span>
<span class="n">viz_w</span><span class="o">.</span><span class="n">set_min_max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">max_w</span><span class="p">)</span>  <span class="c"># color scale</span>
<span class="n">viz_w</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>    <span class="c"># bring settings above into action</span>
<span class="n">viz_w</span><span class="o">.</span><span class="n">write_png</span><span class="p">(</span><span class="s">&#39;deflection.png&#39;</span><span class="p">)</span>
<span class="n">viz_w</span><span class="o">.</span><span class="n">write_ps</span><span class="p">(</span><span class="s">&#39;deflection&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;eps&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">format</span></tt> argument in the latter line can also take the values
<tt class="docutils literal"><span class="pre">'ps'</span></tt> for a standard PostScript file and <tt class="docutils literal"><span class="pre">'pdf'</span></tt> for a PDF file.
Note the necessity of the <tt class="docutils literal"><span class="pre">viz_w.update(w)</span></tt> call &#8211; without it we
will not see the effects of tilting the camera and changing the color
scale.  Figure <a class="reference internal" href="#tut-poisson-2d-fig1"><em>Plot of the deflection of a membrane</em></a> shows the resulting scalar
surface.</p>
<div class="figure" id="tut-poisson-2d-fig1">
<a class="reference internal image-reference" href="../../_images/membrane_waxis.png"><img alt="../../_images/membrane_waxis.png" src="../../_images/membrane_waxis.png" style="width: 480px;" /></a>
<p class="caption">Plot of the deflection of a membrane</p>
</div>
</div>
<div class="section" id="computing-derivatives">
<span id="tut-poisson-gradu"></span><h2>Computing Derivatives<a class="headerlink" href="#computing-derivatives" title="Permalink to this headline">¶</a></h2>
<p>In Poisson and many other problems the gradient of the solution is of
interest. The computation is in principle simple: since <span class="math">\(u =
\sum_{j=1}^N U_j \phi_j\)</span>, we have that</p>
<div class="math">
\[\nabla u = \sum_{j=1}^N U_j \nabla \phi_j\thinspace .\]</div>
<p>Given the solution variable <tt class="docutils literal"><span class="pre">u</span></tt> in the program, its gradient is
obtained by <tt class="docutils literal"><span class="pre">grad(u)</span></tt> or <tt class="docutils literal"><span class="pre">nabla_grad(u)</span></tt>.  However, the gradient
of a piecewise continuous finite element scalar field is a
discontinuous vector field since the <span class="math">\(\phi_j\)</span> has discontinuous
derivatives at the boundaries of the cells. For example, using
Lagrange elements of degree 1, <span class="math">\(u\)</span> is linear over each cell, and
the numerical <span class="math">\(\nabla u\)</span> becomes a piecewise constant vector
field. On the contrary, the exact gradient is continuous.  For
visualization and data analysis purposes we often want the computed
gradient to be a continuous vector field. Typically, we want each
component of <span class="math">\(\nabla u\)</span> to be represented in the same way as
<span class="math">\(u\)</span> itself. To this end, we can project the components of
<span class="math">\(\nabla u\)</span> onto the same function space as we used for
<span class="math">\(u\)</span>.  This means that we solve <span class="math">\(w = \nabla u\)</span>
approximately by a finite element method, using the same elements for
the components of <span class="math">\(w\)</span> as we used for <span class="math">\(u\)</span>. This process is
known as <em>projection</em>.</p>
<p id="index-47">Looking at the component <span class="math">\(\partial u/\partial x\)</span> of the
gradient, we project the (discrete) derivative
<span class="math">\(\sum_jU_j{\partial \phi_j/\partial x}\)</span> onto a function space
with basis <span class="math">\(\phi_1,\phi_2,\ldots\)</span> such that the derivative in
this space is expressed by the standard sum <span class="math">\(\sum_j\bar U_j
\phi_j\)</span>, for suitable (new) coefficients <span class="math">\(\bar U_j\)</span>.</p>
<p>The variational problem for <span class="math">\(w\)</span> reads: find <span class="math">\(w\in
V^{(\mbox{g})}\)</span> such that</p>
<div class="math">
\[a(w, v) = L(v)\quad\forall v\in \hat{V^{(\mbox{g})}},\]</div>
<p>where</p>
<div class="math">
\[\begin{split}a(w, v) &amp;= \int_\Omega w\cdot v \, \mathrm{d}x,\\
L(v) &amp;= \int_\Omega \nabla u\cdot v \, \mathrm{d}x\thinspace .\end{split}\]</div>
<p>The function spaces <span class="math">\(V^{(\mbox{g})}\)</span> and
<span class="math">\(\hat{V^{(\mbox{g})}}\)</span> (with the superscript g denoting
&#8220;gradient&#8221;) are vector versions of the function space for <span class="math">\(u\)</span>,
with boundary conditions removed (if <span class="math">\(V\)</span> is the space we used
for <span class="math">\(u\)</span>, with no restrictions on boundary values,
<span class="math">\(V^{(\mbox{g})} = \hat{V^{(\mbox{g})}} = [V]^d\)</span>, where <span class="math">\(d\)</span>
is the number of space dimensions).  For example, if we used piecewise
linear functions on the mesh to approximate <span class="math">\(u\)</span>, the variational
problem for <span class="math">\(w\)</span> corresponds to approximating each component
field of <span class="math">\(w\)</span> by piecewise linear functions.</p>
<p>The variational problem for the vector field <span class="math">\(w\)</span>, called
<tt class="docutils literal"><span class="pre">grad_u</span></tt> in the code, is easy to solve in FEniCS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V_g</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V_g</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V_g</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">grad_u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V_g</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">grad_u</span><span class="p">)</span>

<span class="n">plot</span><span class="p">(</span><span class="n">grad_u</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;grad(u)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The boundary condition argument to <tt class="docutils literal"><span class="pre">solve</span></tt> is dropped since there
are no essential boundary conditions in this problem.  The new thing
is basically that we work with a <tt class="docutils literal"><span class="pre">VectorFunctionSpace</span></tt>, since the
unknown is now a vector field, instead of the <tt class="docutils literal"><span class="pre">FunctionSpace</span></tt> object
for scalar fields.  Figure <a class="reference internal" href="#tut-poisson-2d-fig-ex1-gradu"><em>Example of visualizing the vector field  by arrows
at the nodes</em></a> shows
example of how Viper can visualize such a vector field.</p>
<div class="figure" id="tut-poisson-2d-fig-ex1-gradu">
<a class="reference internal image-reference" href="../../_images/ex1_gradu.png"><img alt="../../_images/ex1_gradu.png" src="../../_images/ex1_gradu.png" style="width: 480px;" /></a>
<p class="caption">Example of visualizing the vector field <span class="math">\(\nabla u\)</span> by arrows
at the nodes</p>
</div>
<p>The scalar component fields of the gradient can be extracted as
separate fields and, e.g., visualized:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">grad_u_x</span><span class="p">,</span> <span class="n">grad_u_y</span> <span class="o">=</span> <span class="n">grad_u</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># extract components</span>
<span class="n">plot</span><span class="p">(</span><span class="n">grad_u_x</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;x-component of grad(u)&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">grad_u_y</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;y-component of grad(u)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">deepcopy=True</span></tt> argument signifies a <em>deep copy</em>, which is a
general term in computer science implying that a copy of the data is
returned. (The opposite, <tt class="docutils literal"><span class="pre">deepcopy=False</span></tt>, means a <em>shallow copy</em>,
where the returned objects are just pointers to the original data.)</p>
<span class="target" id="index-48"></span><span class="target" id="index-49"></span><p id="index-50">The <tt class="docutils literal"><span class="pre">grad_u_x</span></tt> and <tt class="docutils literal"><span class="pre">grad_u_y</span></tt> variables behave as <tt class="docutils literal"><span class="pre">Function</span></tt>
objects. In particular, we can extract the underlying arrays of nodal
values by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">grad_u_x_array</span> <span class="o">=</span> <span class="n">grad_u_x</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="n">grad_u_y_array</span> <span class="o">=</span> <span class="n">grad_u_y</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>The degrees of freedom of the <tt class="docutils literal"><span class="pre">grad_u</span></tt> vector field can also be
reached by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">grad_u_array</span> <span class="o">=</span> <span class="n">grad_u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>but this is a flat <tt class="docutils literal"><span class="pre">numpy</span></tt> array where the degrees of freedom for
the <span class="math">\(x\)</span> component of the gradient is stored in the first part,
then the degrees of freedom of the <span class="math">\(y\)</span> component, and so on.</p>
<p id="index-51">The program <tt class="docutils literal"><span class="pre">d5_p2D.py</span></tt> extends the code <tt class="docutils literal"><span class="pre">d5_p2D.py</span></tt> from the
section <a class="reference internal" href="#tut-poisson1-verify1"><em>Examining the Discrete Solution</em></a> with computations and
visualizations of the gradient.  Examining the arrays
<tt class="docutils literal"><span class="pre">grad_u_x_array</span></tt> and <tt class="docutils literal"><span class="pre">grad_u_y_array</span></tt>, or looking at the plots of
<tt class="docutils literal"><span class="pre">grad_u_x</span></tt> and <tt class="docutils literal"><span class="pre">grad_u_y</span></tt>, quickly reveals that the computed
<tt class="docutils literal"><span class="pre">grad_u</span></tt> field does not equal the exact gradient <span class="math">\((2x, 4y)\)</span> in
this particular test problem where <span class="math">\(u=1+x^2+2y^2\)</span>.  There are
inaccuracies at the boundaries, arising from the approximation problem
for <span class="math">\(w\)</span>. Increasing the mesh resolution shows, however, that the
components of the gradient vary linearly as <span class="math">\(2x\)</span> and <span class="math">\(4y\)</span>
in the interior of the mesh (i.e., as soon as we are one element away
from the boundary). See the section <a class="reference internal" href="#tut-quickviz"><em>Quick Visualization with VTK</em></a> for
illustrations of this phenomenon.</p>
<span class="target" id="index-52"></span><p id="index-53">Projecting some function onto some space is a very common operation in
finite element programs. The manual steps in this process have
therefore been collected in a utility function <tt class="docutils literal"><span class="pre">project(q,</span> <span class="pre">W)</span></tt>,
which returns the projection of some <tt class="docutils literal"><span class="pre">Function</span></tt> or <tt class="docutils literal"><span class="pre">Expression</span></tt>
object named <tt class="docutils literal"><span class="pre">q</span></tt> onto the <tt class="docutils literal"><span class="pre">FunctionSpace</span></tt> or
<tt class="docutils literal"><span class="pre">VectorFunctionSpace</span></tt> named <tt class="docutils literal"><span class="pre">W</span></tt>.  Specifically, the previous code
for projecting each component of <tt class="docutils literal"><span class="pre">grad(u)</span></tt> onto the same space that
we use for <tt class="docutils literal"><span class="pre">u</span></tt>, can now be done by a one-line call</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">grad_u</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>The applications of projection are many, including turning
discontinuous gradient fields into continuous ones, comparing higher-
and lower-order function approximations, and transforming a
higher-order finite element solution down to a piecewise linear field,
which is required by many visualization packages.</p>
</div>
<div class="section" id="a-variable-coefficient-poisson-problem">
<span id="tut-possion-2d-varcoeff"></span><h2>A Variable-Coefficient Poisson Problem<a class="headerlink" href="#a-variable-coefficient-poisson-problem" title="Permalink to this headline">¶</a></h2>
<p id="index-54">Suppose we have a variable coefficient <span class="math">\(p(x,y)\)</span> in the Laplace
operator, as in the boundary-value problem</p>
<div class="math" id="equation-tut:poisson:2D:varcoeff">
<span class="eqno">(10)</span>\[\begin{split}         - \nabla\cdot \left\lbrack
     p(x,y)\nabla u(x,y)\right\rbrack &amp;= f(x,y) \quad \mbox{in } \Omega,
         \\
         u(x,y) &amp;= u_0(x,y) \quad \mbox{on}\  \partial\Omega\thinspace .\end{split}\]</div>
<p>We shall quickly demonstrate that this simple extension of our model
problem only requires an equally simple extension of the FEniCS
program.</p>
<p>Let us continue to use our favorite solution <span class="math">\(u(x,y)=1+x^2+2y^2\)</span>
and then prescribe <span class="math">\(p(x,y)=x+y\)</span>. It follows that <span class="math">\(u_0(x,y)
= 1 + x^2 + 2y^2\)</span> and <span class="math">\(f(x,y)=-8x-10y\)</span>.</p>
<p id="index-55">What are the modifications we need to do in the <tt class="docutils literal"><span class="pre">d4_p2D.py</span></tt> program
from the section <a class="reference internal" href="#tut-poisson1-verify1"><em>Examining the Discrete Solution</em></a>?</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> must be an <tt class="docutils literal"><span class="pre">Expression</span></tt> since it is no longer a constant,</li>
<li>a new <tt class="docutils literal"><span class="pre">Expression</span></tt> <cite>p</cite> must be defined for the variable
coefficient,</li>
<li>the variational problem is slightly changed.</li>
</ul>
</div></blockquote>
<p>First we address the modified variational problem. Multiplying the PDE
by a test function <span class="math">\(v\)</span> and integrating by parts now results in</p>
<div class="math">
\[\int_\Omega p\nabla u\cdot\nabla v \, \mathrm{d}x -
\int_{\partial\Omega} p{\partial u\over
\partial n}v \, \mathrm{d}s = \int_\Omega fv \, \mathrm{d}x\thinspace .\]</div>
<p>The function spaces for <span class="math">\(u\)</span> and <span class="math">\(v\)</span> are the same as in the
section <a class="reference internal" href="#tut-poisson1-varform"><em>Variational Formulation</em></a>, implying that the boundary
integral vanishes since <span class="math">\(v=0\)</span> on <span class="math">\(\partial\Omega\)</span> where we
have Dirichlet conditions.  The weak form <span class="math">\(a(u,v)=L(v)\)</span> then has</p>
<div class="math">
\[\begin{split}a(u,v) &amp;= \int_\Omega p\nabla u\cdot\nabla v \, \mathrm{d}x,\\
L(v) &amp;= \int_\Omega fv \, \mathrm{d}x\thinspace .\end{split}\]</div>
<p>In the code from the section <a class="reference internal" href="#tut-poisson1-impl"><em>Implementation (1)</em></a> we must replace</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>The definitions of <tt class="docutils literal"><span class="pre">p</span></tt> and <tt class="docutils literal"><span class="pre">f</span></tt> read</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;x[0] + x[1]&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-8*x[0] - 10*x[1]&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>No additional modifications are necessary. The complete code can be
found in in the file <tt class="docutils literal"><span class="pre">vcp2D.py</span></tt> (variable-coefficient Poisson
problem in 2D).  You can run it and confirm that it recovers the exact
<span class="math">\(u\)</span> at the nodes.</p>
<p>The flux <span class="math">\(-p\nabla u\)</span> may be of particular interest in
variable-coefficient Poisson problems as it often has an interesting
physical significance. As explained in the section
<a class="reference internal" href="#tut-poisson-gradu"><em>Computing Derivatives</em></a>, we normally want the piecewise discontinuous
flux or gradient to be approximated by a continuous vector field,
using the same elements as used for the numerical solution
<span class="math">\(u\)</span>. The approximation now consists of solving <span class="math">\(w =
-p\nabla u\)</span> by a finite element method: find <span class="math">\(w\in
V^{(\mbox{g})}\)</span> such that</p>
<div class="math">
\[a(w, v) = L(v)\quad\forall v\in \hat{V^{(\mbox{g})}},\]</div>
<p>where</p>
<div class="math">
\[\begin{split}a(w, v) &amp;= \int_\Omega w\cdot v \, \mathrm{d}x,\\
L(v) &amp;= \int_\Omega (-p \nabla u)\cdot v \, \mathrm{d}x\thinspace .\end{split}\]</div>
<p>This problem is identical to the one in the section
<a class="reference internal" href="#tut-poisson-gradu"><em>Computing Derivatives</em></a>, except that <span class="math">\(p\)</span> enters the integral in
<span class="math">\(L\)</span>.</p>
<p>The relevant Python statements for computing the flux field take the
form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V_g</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V_g</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V_g</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">flux</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V_g</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">flux</span><span class="p">)</span>
</pre></div>
</div>
<p>The following call to <tt class="docutils literal"><span class="pre">project</span></tt> is equivalent to the above
statements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">flux</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span>
               <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Plotting the flux vector field is naturally as easy as plotting the
gradient (see the section <a class="reference internal" href="#tut-poisson-gradu"><em>Computing Derivatives</em></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;flux field&#39;</span><span class="p">)</span>

<span class="n">flux_x</span><span class="p">,</span> <span class="n">flux_y</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># extract components</span>
<span class="n">plot</span><span class="p">(</span><span class="n">flux_x</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;x-component of flux (-p*grad(u))&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">flux_y</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;y-component of flux (-p*grad(u))&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>For data analysis of the nodal values of the flux field we can grab
the underlying <tt class="docutils literal"><span class="pre">numpy</span></tt> arrays:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">flux_x_array</span> <span class="o">=</span> <span class="n">flux_x</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="n">flux_y_array</span> <span class="o">=</span> <span class="n">flux_y</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>The program <tt class="docutils literal"><span class="pre">vcp2D.py</span></tt> contains in addition some plots, including a
curve plot comparing <tt class="docutils literal"><span class="pre">flux_x</span></tt> and the exact counterpart along the
line <span class="math">\(y=1/2\)</span>.  The associated programming details related to
this visualization are explained in the section <a class="reference internal" href="#tut-structviz"><em>Visualization of Structured Mesh Data</em></a>.</p>
</div>
<div class="section" id="computing-functionals">
<span id="tut-poisson1-functionals"></span><h2>Computing Functionals<a class="headerlink" href="#computing-functionals" title="Permalink to this headline">¶</a></h2>
<p id="index-56">After the solution <span class="math">\(u\)</span> of a PDE is computed, we occasionally
want to compute functionals of <span class="math">\(u\)</span>, for example,</p>
<div class="math" id="equation-tut:poisson1:functionals:energy">
<span class="eqno">(11)</span>\[     {1\over2}||\nabla u||^2 \equiv {1\over2}\int_\Omega \nabla u\cdot \nabla u \, \mathrm{d}x,\]</div>
<p>which often reflects some energy quantity.  Another frequently
occurring functional is the error</p>
<div class="math" id="equation-tut:poisson1:functionals:error">
<span class="eqno">(12)</span>\[     ||u_{\mbox{e}}-u|| = \left(\int_\Omega (u_{\mbox{e}}-u)^2 \, \mathrm{d}x\right)^{1/2},\]</div>
<p>where <span class="math">\(u_{\rm e}\)</span> is the exact solution. The error is of
particular interest when studying convergence properties.  Sometimes
the interest concerns the flux out of a part <span class="math">\(\Gamma\)</span> of the
boundary <span class="math">\(\partial\Omega\)</span>,</p>
<div class="math" id="equation-tut:poisson1:functionals:flux">
<span class="eqno">(13)</span>\[     F = -\int_\Gamma p\nabla u\cdot\pmb{n} \, \mathrm{d}s,\]</div>
<p>where <span class="math">\(\pmb{n}\)</span> is an outward unit normal at <span class="math">\(\Gamma\)</span> and
<span class="math">\(p\)</span> is a coefficient (see the problem in the section
<a class="reference internal" href="#tut-possion-2d-varcoeff"><em>A Variable-Coefficient Poisson Problem</em></a> for a specific example).  All these
functionals are easy to compute with FEniCS, and this section
describes how it can be done.</p>
<p id="index-57"><em>Energy Functional.</em> The integrand of the energy functional
<span class="math">\({1\over2}\int_\Omega \nabla u\cdot \nabla u \, \mathrm{d}x\)</span> is
described in the UFL language in the same manner as we describe weak
forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">energy</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">assemble</span></tt> call performs the integration.  It is possible to
restrict the integration to subdomains, or parts of the boundary, by
using a mesh function to mark the subdomains as explained in the
section <a class="reference internal" href="materials.html#tut-poisson-mat-neumann"><em>Multiple Neumann, Robin, and Dirichlet Condition</em></a>.  The program <tt class="docutils literal"><span class="pre">membrane2.py</span></tt>
carries out the computation of the elastic energy</p>
<div class="math" id="index-58">
\[{1\over2}||T\nabla D||^2 = {1\over2}\left({AR\over 8\pi\sigma}\right)^2
||\nabla w||^2\]</div>
<p>in the membrane problem from the section <a class="reference internal" href="#tut-poisson-membrane"><em>Solving a Real Physical Problem</em></a>.</p>
<p id="index-59"><em>Convergence Estimation.</em> To illustrate error computations and
convergence of finite element solutions, we modify the <tt class="docutils literal"><span class="pre">d5_p2D.py</span></tt>
program from the section <a class="reference internal" href="#tut-poisson-gradu"><em>Computing Derivatives</em></a> and specify a more
complicated solution,</p>
<div class="math">
\[u(x,y) = \sin(\omega\pi x)\sin(\omega\pi y)\]</div>
<p>on the unit square.  This choice implies <span class="math">\(f(x,y)=2\omega^2\pi^2
u(x,y)\)</span>.  With <span class="math">\(\omega\)</span> restricted to an integer it follows that
<span class="math">\(u_0=0\)</span>.</p>
<p id="index-60">We need to define the appropriate boundary conditions, the exact
solution, and the <span class="math">\(f\)</span> function in the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">boundary</span><span class="p">)</span>

<span class="n">omega</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;sin(omega*pi*x[0])*sin(omega*pi*x[1])&#39;</span><span class="p">,</span>
                 <span class="n">omega</span><span class="o">=</span><span class="n">omega</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u_e</span>
</pre></div>
</div>
<p>The computation of <span class="math">\(\left(\int_\Omega (u_e-u)^2 \,
\mathrm{d}x\right)^{1/2}\)</span> can be done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
</pre></div>
</div>
<p>Here, <tt class="docutils literal"><span class="pre">u_e</span></tt> will be interpolated onto the function space <tt class="docutils literal"><span class="pre">V</span></tt>. This
implies that the exact solution used in the integral will vary
linearly over the cells, and not as a sine function, if <tt class="docutils literal"><span class="pre">V</span></tt>
corresponds to linear Lagrange elements.  This situation may yield a
smaller error <tt class="docutils literal"><span class="pre">u</span> <span class="pre">-</span> <span class="pre">u_e</span></tt> than what is actually true.</p>
<p>More accurate representation of the exact solution is easily achieved
by interpolating the formula onto a space defined by higher-order
elements, say of third degree:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Ve</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">u_e_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e_Ve</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
</pre></div>
</div>
<p>To achieve complete mathematical control of which function space the
computations are carried out in, we can explicitly interpolate <tt class="docutils literal"><span class="pre">u</span></tt>
to the same space:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_Ve</span> <span class="o">-</span> <span class="n">u_e_Ve</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>The square in the expression for <tt class="docutils literal"><span class="pre">error</span></tt> will be expanded and lead
to a lot of terms that almost cancel when the error is small, with the
potential of introducing significant round-off errors.  The function
<tt class="docutils literal"><span class="pre">errornorm</span></tt> is available for avoiding this effect by first
interpolating <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">u_e</span></tt> to a space with higher-order elements,
then subtracting the degrees of freedom, and then performing the
integration of the error field. The usage is simple:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">E</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">normtype</span><span class="o">=</span><span class="s">&#39;L2&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>It is illustrative to look at the short implementation of
<tt class="docutils literal"><span class="pre">errornorm</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">errornorm</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">):</span>
    <span class="n">u_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
    <span class="n">u_e_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
    <span class="n">e_Ve</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Ve</span><span class="p">)</span>
    <span class="c"># Subtract degrees of freedom for the error field</span>
    <span class="n">e_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u_e_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> \
                       <span class="n">u_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">e_Ve</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">errornorm</span></tt> procedure turns out to be identical to computing the
expression <tt class="docutils literal"><span class="pre">(u_e</span> <span class="pre">-</span> <span class="pre">u)**2*dx</span></tt> directly in the present test case.</p>
<p>Sometimes it is of interest to compute the error of the gradient
field: <span class="math">\(||\nabla (u-u_{\mbox{e}})||\)</span> (often referred to as the
<span class="math">\(H^1\)</span> seminorm of the error).  Given the error field <tt class="docutils literal"><span class="pre">e_Ve</span></tt>
above, we simply write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">H1seminorm</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">e_Ve</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">e_Ve</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span><span class="p">))</span>
</pre></div>
</div>
<p>Finally, we remove all <tt class="docutils literal"><span class="pre">plot</span></tt> calls and printouts of <span class="math">\(u\)</span>
values in the original program, and collect the computations in a
function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">):</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquare</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="n">Ve</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">E</span>
</pre></div>
</div>
<p>Calling <tt class="docutils literal"><span class="pre">compute</span></tt> for finer and finer meshes enables us to study the
convergence rate. Define the element size <span class="math">\(h=1/n\)</span>, where
<span class="math">\(n\)</span> is the number of divisions in <span class="math">\(x\)</span> and <span class="math">\(y\)</span>
direction (<tt class="docutils literal"><span class="pre">nx=ny</span></tt> in the code). We perform experiments with
<span class="math">\(h_0&gt;h_1&gt;h_2\cdots\)</span> and compute the corresponding errors
<span class="math">\(E_0, E_1, E_3\)</span> and so forth.  Assuming <span class="math">\(E_i=Ch_i^r\)</span> for
unknown constants <span class="math">\(C\)</span> and <span class="math">\(r\)</span>, we can compare two
consecutive experiments, <span class="math">\(E_i=Ch_i^r\)</span> and
<span class="math">\(E_{i-1}=Ch_{i-1}^r\)</span>, and solve for <span class="math">\(r\)</span>:</p>
<div class="math">
\[r = {\ln(E_i/E_{i-1})\over\ln (h_i/h_{i-1})}\thinspace .\]</div>
<p>The <span class="math">\(r\)</span> values should approach the expected convergence rate
<tt class="docutils literal"><span class="pre">degree+1</span></tt> as <span class="math">\(i\)</span> increases.</p>
<p>The procedure above can easily be turned into Python code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">degree</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c"># read degree as 1st command-line arg</span>
<span class="n">h</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># element sizes</span>
<span class="n">E</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># errors</span>
<span class="k">for</span> <span class="n">nx</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">264</span><span class="p">]:</span>
    <span class="n">h</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">nx</span><span class="p">)</span>
    <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compute</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">degree</span><span class="p">))</span>

<span class="c"># Convergence rates</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span> <span class="k">as</span> <span class="n">ln</span>  <span class="c"># (log is a dolfin name too - and logg :-)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">ln</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">ln</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">print</span> <span class="s">&#39;h=</span><span class="si">%10.2E</span><span class="s"> r=.2f&#39;</span>  <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting program has the name <tt class="docutils literal"><span class="pre">d6_p2D.py</span></tt> and computes error
norms in various ways. Running this program for elements of first
degree and <span class="math">\(\omega=1\)</span> yields the output</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">h</span><span class="o">=</span><span class="mf">1.25E-01</span> <span class="n">E</span><span class="o">=</span><span class="mf">3.25E-02</span> <span class="n">r</span><span class="o">=</span><span class="mf">1.83</span>
<span class="n">h</span><span class="o">=</span><span class="mf">6.25E-02</span> <span class="n">E</span><span class="o">=</span><span class="mf">8.37E-03</span> <span class="n">r</span><span class="o">=</span><span class="mf">1.96</span>
<span class="n">h</span><span class="o">=</span><span class="mf">3.12E-02</span> <span class="n">E</span><span class="o">=</span><span class="mf">2.11E-03</span> <span class="n">r</span><span class="o">=</span><span class="mf">1.99</span>
<span class="n">h</span><span class="o">=</span><span class="mf">1.56E-02</span> <span class="n">E</span><span class="o">=</span><span class="mf">5.29E-04</span> <span class="n">r</span><span class="o">=</span><span class="mf">2.00</span>
<span class="n">h</span><span class="o">=</span><span class="mf">7.81E-03</span> <span class="n">E</span><span class="o">=</span><span class="mf">1.32E-04</span> <span class="n">r</span><span class="o">=</span><span class="mf">2.00</span>
<span class="n">h</span><span class="o">=</span><span class="mf">3.79E-03</span> <span class="n">E</span><span class="o">=</span><span class="mf">3.11E-05</span> <span class="n">r</span><span class="o">=</span><span class="mf">2.00</span>
</pre></div>
</div>
<p>That is, we approach the expected second-order convergence of linear
Lagrange elements as the meshes become sufficiently fine.</p>
<p>Running the program for second-degree elements results in the expected
value <span class="math">\(r=3\)</span>,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">h</span><span class="o">=</span><span class="mf">1.25E-01</span> <span class="n">E</span><span class="o">=</span><span class="mf">5.66E-04</span> <span class="n">r</span><span class="o">=</span><span class="mf">3.09</span>
<span class="n">h</span><span class="o">=</span><span class="mf">6.25E-02</span> <span class="n">E</span><span class="o">=</span><span class="mf">6.93E-05</span> <span class="n">r</span><span class="o">=</span><span class="mf">3.03</span>
<span class="n">h</span><span class="o">=</span><span class="mf">3.12E-02</span> <span class="n">E</span><span class="o">=</span><span class="mf">8.62E-06</span> <span class="n">r</span><span class="o">=</span><span class="mf">3.01</span>
<span class="n">h</span><span class="o">=</span><span class="mf">1.56E-02</span> <span class="n">E</span><span class="o">=</span><span class="mf">1.08E-06</span> <span class="n">r</span><span class="o">=</span><span class="mf">3.00</span>
<span class="n">h</span><span class="o">=</span><span class="mf">7.81E-03</span> <span class="n">E</span><span class="o">=</span><span class="mf">1.34E-07</span> <span class="n">r</span><span class="o">=</span><span class="mf">3.00</span>
<span class="n">h</span><span class="o">=</span><span class="mf">3.79E-03</span> <span class="n">E</span><span class="o">=</span><span class="mf">1.53E-08</span> <span class="n">r</span><span class="o">=</span><span class="mf">3.00</span>
</pre></div>
</div>
<p>However, using <tt class="docutils literal"><span class="pre">(u</span> <span class="pre">-</span> <span class="pre">u_e)**2</span></tt> for the error computation, which
implies interpolating <tt class="docutils literal"><span class="pre">u_e</span></tt> onto the same space as <tt class="docutils literal"><span class="pre">u</span></tt>, results in
<span class="math">\(r=4\)</span> (!). This is an example where it is important to
interpolate <tt class="docutils literal"><span class="pre">u_e</span></tt> to a higher-order space (polynomials of degree 3
are sufficient here) to avoid computing a too optimistic convergence
rate.</p>
<p>Running the program for third-degree elements results in the expected
value <span class="math">\(r=4\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">h</span><span class="o">=</span>  <span class="mf">1.25E-01</span> <span class="n">r</span><span class="o">=</span><span class="mf">4.09</span>
<span class="n">h</span><span class="o">=</span>  <span class="mf">6.25E-02</span> <span class="n">r</span><span class="o">=</span><span class="mf">4.03</span>
<span class="n">h</span><span class="o">=</span>  <span class="mf">3.12E-02</span> <span class="n">r</span><span class="o">=</span><span class="mf">4.01</span>
<span class="n">h</span><span class="o">=</span>  <span class="mf">1.56E-02</span> <span class="n">r</span><span class="o">=</span><span class="mf">4.00</span>
<span class="n">h</span><span class="o">=</span>  <span class="mf">7.81E-03</span> <span class="n">r</span><span class="o">=</span><span class="mf">4.00</span>
</pre></div>
</div>
<p>Checking convergence rates is the next best method for verifying PDE
codes (the best being exact recovery of a solution as in the section
<a class="reference internal" href="#tut-poisson1-verify1"><em>Examining the Discrete Solution</em></a> and many other places in this tutorial).</p>
<p id="index-61"><em>Flux Functionals.</em> To compute flux integrals like <span class="math">\(\int_\Gamma
p\nabla u\cdot\pmb{n} \, \mathrm{d}s\)</span> we need to define the
<span class="math">\(\pmb{n}\)</span> vector, referred to as <em>facet normal</em> in FEniCS. If
<span class="math">\(\Gamma\)</span> is the complete boundary we can perform the flux
computation by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">n</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">flux</span> <span class="o">=</span> <span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span>
<span class="n">total_flux</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
</pre></div>
</div>
<p>Although <tt class="docutils literal"><span class="pre">nabla_grad(u)</span></tt> and <tt class="docutils literal"><span class="pre">grad(u)</span></tt> are interchangeable in the
above expression when <tt class="docutils literal"><span class="pre">u</span></tt> is a scalar function, we have chosen to
write <tt class="docutils literal"><span class="pre">nabla_grad(u)</span></tt> because this is the right expression if we
generalize the underlying equation to a vector Laplace/Poisson
PDE. With <tt class="docutils literal"><span class="pre">grad(u)</span></tt> we must in that case write <tt class="docutils literal"><span class="pre">dot(n,</span> <span class="pre">grad(u))</span></tt>.</p>
<p>It is possible to restrict the integration to a part of the boundary
using a mesh function to mark the relevant part, as explained in the
section <a class="reference internal" href="materials.html#tut-poisson-mat-neumann"><em>Multiple Neumann, Robin, and Dirichlet Condition</em></a>. Assuming that the part
corresponds to subdomain number <tt class="docutils literal"><span class="pre">i</span></tt>, the relevant form for the flux
is <tt class="docutils literal"><span class="pre">-p*inner(grad(u),</span> <span class="pre">n)*ds(i)</span></tt>.</p>
</div>
<div class="section" id="visualization-of-structured-mesh-data">
<span id="tut-structviz"></span><h2>Visualization of Structured Mesh Data<a class="headerlink" href="#visualization-of-structured-mesh-data" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-62"></span><span class="target" id="index-63"></span><p id="index-64">When finite element computations are done on a structured rectangular
mesh, maybe with uniform partitioning, VTK-based tools for completely
unstructured 2D/3D meshes are not required.  Instead we can use
visualization and data analysis tools for <em>structured data</em>.  Such
data typically appear in finite difference simulations and image
analysis.  Analysis and visualization of structured data are faster
and easier than doing the same with data on unstructured meshes, and
the collection of tools to choose among is much larger.  We shall
demonstrate the potential of such tools and how they allow for
tailored and flexible visualization and data analysis.</p>
<span class="target" id="index-65"></span><p id="index-66">A necessary first step is to transform our <tt class="docutils literal"><span class="pre">mesh</span></tt> object to an
object representing a rectangle with equally-shaped <em>rectangular</em>
cells.  The Python package <tt class="docutils literal"><span class="pre">scitools</span></tt>
(<a class="reference external" href="code.google.com/p/scitools">code.google.com/p/scitools</a>) has this type of structure, called a
<tt class="docutils literal"><span class="pre">UniformBoxGrid</span></tt>. The second step is to transform the
one-dimensional array of nodal values to a two-dimensional array
holding the values at the corners of the cells in the structured
grid. In such grids, we want to access a value by its <span class="math">\(i\)</span> and
<span class="math">\(j\)</span> indices, <span class="math">\(i\)</span> counting cells in the <span class="math">\(x\)</span>
direction, and <span class="math">\(j\)</span> counting cells in the <span class="math">\(y\)</span> direction.
This transformation is in principle straightforward, yet it frequently
leads to obscure indexing errors. The <tt class="docutils literal"><span class="pre">BoxField</span></tt> object in
<tt class="docutils literal"><span class="pre">scitools</span></tt> takes conveniently care of the details of the
transformation.  With a <tt class="docutils literal"><span class="pre">BoxField</span></tt> defined on a <tt class="docutils literal"><span class="pre">UniformBoxGrid</span></tt>
it is very easy to call up more standard plotting packages to
visualize the solution along lines in the domain or as 2D contours or
lifted surfaces.</p>
<p>Let us go back to the <tt class="docutils literal"><span class="pre">vcp2D.py</span></tt> code from the section
<a class="reference internal" href="#tut-possion-2d-varcoeff"><em>A Variable-Coefficient Poisson Problem</em></a> and map <tt class="docutils literal"><span class="pre">u</span></tt> onto a <tt class="docutils literal"><span class="pre">BoxField</span></tt>
object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scitools.BoxField</span>
<span class="n">u2</span> <span class="o">=</span> <span class="n">u</span> <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> \
     <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">u_box</span> <span class="o">=</span> <span class="n">scitools</span><span class="o">.</span><span class="n">BoxField</span><span class="o">.</span><span class="n">dolfin_function2BoxField</span><span class="p">(</span>
        <span class="n">u2</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">),</span> <span class="n">uniform_mesh</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The function <tt class="docutils literal"><span class="pre">dolfin_function2BoxField</span></tt> can only work with finite
element fields with <em>linear</em> (degree 1) elements, so for higher-degree
elements we here simply interpolate the solution onto a mesh with
linear elements. We could also interpolate/project onto a finer mesh
in the higher-degree case.  Such transformations to linear finite
element fields are very often needed when calling up plotting packages
or data analysis tools.  The <tt class="docutils literal"><span class="pre">u.ufl_element()</span></tt> method returns an
object holding the element type, and this object has a method
<tt class="docutils literal"><span class="pre">degree()</span></tt> for returning the element degree as an integer.  The
parameters <tt class="docutils literal"><span class="pre">nx</span></tt> and <tt class="docutils literal"><span class="pre">ny</span></tt> are the number of divisions in each space
direction that were used when calling <tt class="docutils literal"><span class="pre">UnitSquare</span></tt> to make the
<tt class="docutils literal"><span class="pre">mesh</span></tt> object.  The result <tt class="docutils literal"><span class="pre">u_box</span></tt> is a <tt class="docutils literal"><span class="pre">BoxField</span></tt> object that
supports &#8220;finite difference&#8221; indexing and an underlying grid suitable
for <tt class="docutils literal"><span class="pre">numpy</span></tt> operations on 2D data.  Also 1D and 3D meshes (with
linear elements) can be turned into <tt class="docutils literal"><span class="pre">BoxField</span></tt> objects.</p>
<p>The ability to access a finite element field in the way one can access
a finite difference-type of field is handy in many occasions,
including visualization and data analysis.  Here is an example of
writing out the coordinates and the field value at a grid point with
indices <tt class="docutils literal"><span class="pre">i</span></tt> and <tt class="docutils literal"><span class="pre">j</span></tt> (going from 0 to <tt class="docutils literal"><span class="pre">nx</span></tt> and <tt class="docutils literal"><span class="pre">ny</span></tt>,
respectively, from lower left to upper right corner):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># convenient indices</span>

<span class="n">i</span> <span class="o">=</span> <span class="n">nx</span><span class="p">;</span> <span class="n">j</span> <span class="o">=</span> <span class="n">ny</span>   <span class="c"># upper right corner</span>
<span class="k">print</span> <span class="s">&#39;u(</span><span class="si">%g</span><span class="s">,</span><span class="si">%g</span><span class="s">)=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coor</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                       <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coor</span><span class="p">[</span><span class="n">Y</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
                       <span class="n">u_box</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
</pre></div>
</div>
<p>For instance, the <span class="math">\(x\)</span> coordinates are reached by
<tt class="docutils literal"><span class="pre">u_box.grid.coor[X]</span></tt>.  The <tt class="docutils literal"><span class="pre">grid</span></tt> attribute is an instance of
class <tt class="docutils literal"><span class="pre">UniformBoxGrid</span></tt>.</p>
<p>Many plotting programs can be used to visualize the data in <tt class="docutils literal"><span class="pre">u_box</span></tt>.
Matplotlib is now a very popular plotting program in the Python world
and could be used to make contour plots of <tt class="docutils literal"><span class="pre">u_box</span></tt>. However, other
programs like Gnuplot, VTK, and MATLAB have better support for surface
plots at the time of this writing. Our choice in this tutorial is to
use the Python package <tt class="docutils literal"><span class="pre">scitools.easyviz</span></tt>, which offers a uniform
MATLAB-like syntax as interface to various plotting packages such as
Gnuplot, Matplotlib, VTK, OpenDX, MATLAB, and others. With
<tt class="docutils literal"><span class="pre">scitools.easyviz</span></tt> we write one set of statements, close to what one
would do in MATLAB or Octave, and then it is easy to switch between
different plotting programs, at a later stage, through a command-line
option, a line in a configuration file, or an import statement in the
program.
.. By default, <tt class="docutils literal"><span class="pre">scitools.easyviz</span></tt> employs Gnuplot as plotting program,</p>
<p id="index-67">A contour plot is made by the following <tt class="docutils literal"><span class="pre">scitools.easyviz</span></tt> command:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scitools.easyviz</span> <span class="kn">as</span> <span class="nn">ev</span>
<span class="n">ev</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
           <span class="mi">5</span><span class="p">,</span> <span class="n">clabels</span><span class="o">=</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
<span class="n">evtitle</span><span class="p">(</span><span class="s">&#39;Contour plot of u&#39;</span><span class="p">)</span>
<span class="n">ev</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;u_contours.eps&#39;</span><span class="p">)</span>

<span class="c"># or more compact syntax:</span>
<span class="n">ev</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
           <span class="mi">5</span><span class="p">,</span> <span class="n">clabels</span><span class="o">=</span><span class="s">&#39;on&#39;</span><span class="p">,</span>
           <span class="n">savefig</span><span class="o">=</span><span class="s">&#39;u_contours.eps&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Contour plot of u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting plot can be viewed in Figure
<a class="reference internal" href="#tut-poisson-2d-fig2a"><em>Finite element function on a structured 2D grid: contour plot of
the solution</em></a>.  The <tt class="docutils literal"><span class="pre">contour</span></tt> function needs arrays
with the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> coordinates expanded to 2D arrays (in
the same way as demanded when making vectorized <tt class="docutils literal"><span class="pre">numpy</span></tt> calculations
of arithmetic expressions over all grid points).  The correctly
expanded arrays are stored in <tt class="docutils literal"><span class="pre">grid.coorv</span></tt>.  The above call to
<tt class="docutils literal"><span class="pre">contour</span></tt> creates 5 equally spaced contour lines, and with
<tt class="docutils literal"><span class="pre">clabels='on'</span></tt> the contour values can be seen in the plot.</p>
<p>Other functions for visualizing 2D scalar fields are <tt class="docutils literal"><span class="pre">surf</span></tt> and
<tt class="docutils literal"><span class="pre">mesh</span></tt> as known from MATLAB:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scitools.easyviz</span> <span class="kn">as</span> <span class="nn">ev</span>
<span class="n">ev</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ev</span><span class="o">.</span><span class="n">surf</span><span class="p">(</span><span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">shading</span><span class="o">=</span><span class="s">&#39;interp&#39;</span><span class="p">,</span> <span class="n">colorbar</span><span class="o">=</span><span class="s">&#39;on&#39;</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s">&#39;surf plot of u&#39;</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="s">&#39;u_surf.eps&#39;</span><span class="p">)</span>

<span class="n">ev</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ev</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s">&#39;mesh plot of u&#39;</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="s">&#39;u_mesh.eps&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#tut-poisson-2d-fig3a"><em>Finite element function on a structured 2D grid: surface plot of
the solution</em></a> and <a class="reference internal" href="#tut-poisson-2d-fig3b"><em>Finite element function on a structured 2D grid: lifted mesh plot
of the solution</em></a>
exemplify the surfaces arising from the two plotting commands above.
You can type <tt class="docutils literal"><span class="pre">pydoc</span> <span class="pre">scitools.easyviz</span></tt> in a terminal window to get a
full tutorial.  Note that <tt class="docutils literal"><span class="pre">scitools.easyviz</span></tt> offers function names
like <tt class="docutils literal"><span class="pre">plot</span></tt> and <tt class="docutils literal"><span class="pre">mesh</span></tt>, which clash with <tt class="docutils literal"><span class="pre">plot</span></tt> from <tt class="docutils literal"><span class="pre">dolfin</span></tt>
and the <tt class="docutils literal"><span class="pre">mesh</span></tt> variable in our programs. Therefore, we recommend the
<tt class="docutils literal"><span class="pre">ev</span></tt> prefix.</p>
<p>A handy feature of <tt class="docutils literal"><span class="pre">BoxField</span></tt> is the ability to give a start point
in the grid and a direction, and then extract the field and
corresponding coordinates along the nearest grid line. In 3D fields
one can also extract data in a plane.  Say we want to plot <span class="math">\(u\)</span>
along the line <span class="math">\(y=1/2\)</span> in the grid. The grid points, <tt class="docutils literal"><span class="pre">x</span></tt>, and
the <span class="math">\(u\)</span> values along this line, <tt class="docutils literal"><span class="pre">uval</span></tt>, are extracted by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">uval</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">,</span> <span class="n">snapped</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">gridline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p>The variable <tt class="docutils literal"><span class="pre">snapped</span></tt> is true if the line had to be snapped onto a
gridline and in that case <tt class="docutils literal"><span class="pre">y_fixed</span></tt> holds the snapped (altered)
<span class="math">\(y\)</span> value.  Plotting <span class="math">\(u\)</span> versus the <span class="math">\(x\)</span> coordinate
along this line, using <tt class="docutils literal"><span class="pre">scitools.easyviz</span></tt>, is now a matter of</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ev</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>  <span class="c"># new plot window</span>
<span class="n">ev</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">uval</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">)</span>  <span class="c"># &#39;r--: red solid line</span>
<span class="n">ev</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Solution&#39;</span><span class="p">)</span>
<span class="n">ev</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="s">&#39;finite element solution&#39;</span><span class="p">)</span>

<span class="c"># or more compactly:</span>
<span class="n">ev</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">uval</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Solution&#39;</span><span class="p">,</span>
        <span class="n">legend</span><span class="o">=</span><span class="s">&#39;finite element solution&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>A more exciting plot compares the projected numerical flux in
<span class="math">\(x\)</span> direction along the line <span class="math">\(y=1/2\)</span> with the exact flux:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ev</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">flux2_x</span> <span class="o">=</span> <span class="n">flux_x</span> <span class="k">if</span> <span class="n">flux_x</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> \
          <span class="n">interpolate</span><span class="p">(</span><span class="n">flux_x</span><span class="p">,</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">flux_x_box</span> <span class="o">=</span> <span class="n">scitools</span><span class="o">.</span><span class="n">BoxField</span><span class="o">.</span><span class="n">dolfin_function2BoxField</span><span class="p">(</span>
          <span class="n">flux2_x</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">),</span> <span class="n">uniform_mesh</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">fluxval</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">,</span> <span class="n">snapped</span> <span class="o">=</span> \
          <span class="n">flux_x_box</span><span class="o">.</span><span class="n">gridline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">y_fixed</span>
<span class="n">flux_x_exact</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="n">ev</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fluxval</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">flux_x_exact</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">,</span>
        <span class="n">legend</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;numerical (projected) flux&#39;</span><span class="p">,</span> <span class="s">&#39;exact flux&#39;</span><span class="p">),</span>
        <span class="n">title</span><span class="o">=</span><span class="s">&#39;Flux in x-direction (at y=</span><span class="si">%g</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="n">y_fixed</span><span class="p">,</span>
        <span class="n">savefig</span><span class="o">=</span><span class="s">&#39;flux.eps&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>As seen from Figure <a class="reference internal" href="#tut-poisson-2d-fig2b"><em>Finite element function on a structured 2D grid: curve plot of the
exact flux and the projected numerical flux</em></a>, the numerical flux is
accurate except in the boundary elements.</p>
<p>The visualization constructions shown above and used to generate the
figures are found in the program <tt class="docutils literal"><span class="pre">vcp2D.py</span></tt> in the
<tt class="docutils literal"><span class="pre">stationary/poisson</span></tt> directory.</p>
<div class="figure" id="tut-poisson-2d-fig2a">
<a class="reference internal image-reference" href="../../_images/Poisson2D_Dvc_contour1.png"><img alt="../../_images/Poisson2D_Dvc_contour1.png" src="../../_images/Poisson2D_Dvc_contour1.png" style="width: 480px;" /></a>
<p class="caption">Finite element function on a structured 2D grid: contour plot of
the solution</p>
</div>
<div class="figure" id="tut-poisson-2d-fig2b">
<a class="reference internal image-reference" href="../../_images/Poisson2D_Dvc_flux_x.png"><img alt="../../_images/Poisson2D_Dvc_flux_x.png" src="../../_images/Poisson2D_Dvc_flux_x.png" style="width: 480px;" /></a>
<p class="caption">Finite element function on a structured 2D grid: curve plot of the
exact flux and the projected numerical flux</p>
</div>
<div class="figure" id="tut-poisson-2d-fig3a">
<a class="reference internal image-reference" href="../../_images/Poisson2D_Dvc_surf1.png"><img alt="../../_images/Poisson2D_Dvc_surf1.png" src="../../_images/Poisson2D_Dvc_surf1.png" style="width: 480px;" /></a>
<p class="caption">Finite element function on a structured 2D grid: surface plot of
the solution</p>
</div>
<div class="figure" id="tut-poisson-2d-fig3b">
<a class="reference internal image-reference" href="../../_images/Poisson2D_Dvc_mesh1.png"><img alt="../../_images/Poisson2D_Dvc_mesh1.png" src="../../_images/Poisson2D_Dvc_mesh1.png" style="width: 480px;" /></a>
<p class="caption">Finite element function on a structured 2D grid: lifted mesh plot
of the solution</p>
</div>
<p>It should be easy with the information above to transform a finite
element field over a uniform rectangular or box-shaped mesh to the
corresponding <tt class="docutils literal"><span class="pre">BoxField</span></tt> object and perform MATLAB-style
visualizations of the whole field or the field over planes or along
lines through the domain.  By the transformation to a regular grid we
have some more flexibility than what Viper offers. However, we remark
that comprehensive tools like VisIt, MayaVi2, or ParaView also have
the possibility for plotting fields along lines and extracting planes
in 3D geometries, though usually with less degree of control compared
to Gnuplot, MATLAB, and Matplotlib.  For example, in investigations of
numerical accuracy or numerical artifacts one is often interested in
studying curve plots where only the nodal values sampled. This is
straightforward with a structured mesh data structure, but more
difficult in visualization packages utilizing unstructured grids, as
hitting exactly then nodes when sampling a function along a line
through the grid might be non-trivial.</p>
</div>
<div class="section" id="combining-dirichlet-and-neumann-conditions">
<span id="tut-poisson1-dn"></span><h2>Combining Dirichlet and Neumann Conditions<a class="headerlink" href="#combining-dirichlet-and-neumann-conditions" title="Permalink to this headline">¶</a></h2>
<p>Let us make a slight extension of our two-dimensional Poisson problem
from the section <a class="reference internal" href="#tut-poisson1-bvp"><em>The Poisson equation</em></a> and add a Neumann boundary
condition. The domain is still the unit square, but now we set the
Dirichlet condition <span class="math">\(u=u_0\)</span> at the left and right sides,
<span class="math">\(x=0\)</span> and <span class="math">\(x=1\)</span>, while the Neumann condition</p>
<div class="math">
\[-{\partial u\over\partial n}=g\]</div>
<p>is applied to the remaining sides <span class="math">\(y=0\)</span> and <span class="math">\(y=1\)</span>.  The
Neumann condition is also known as a <em>natural boundary condition</em> (in
contrast to an essential boundary condition).</p>
<p id="index-68">Let <span class="math">\(\Gamma_D\)</span> and <span class="math">\(\Gamma_N\)</span> denote the parts of
<span class="math">\(\partial\Omega\)</span> where the Dirichlet and Neumann conditions
apply, respectively.  The complete boundary-value problem can be
written as</p>
<div class="math">
\[\begin{split}- \nabla^2 u &amp;= f \mbox{ in } \Omega,  \\
u &amp;= u_0 \mbox{ on } \Gamma_D,       \\
- {\partial u\over\partial n} &amp;= g \mbox{ on } \Gamma_N  \thinspace .\end{split}\]</div>
<p>Again we choose <span class="math">\(u=1+x^2 + 2y^2\)</span> as the exact solution and
adjust <span class="math">\(f\)</span>, <span class="math">\(g\)</span>, and <span class="math">\(u_0\)</span> accordingly:</p>
<div class="math">
\[\begin{split}f &amp;= -6,\\
g &amp;= \left\lbrace\begin{array}{ll}
-4, &amp; y=1\\
0,  &amp; y=0
\end{array}\right.\\
u_0 &amp;= 1 + x^2 + 2y^2\thinspace .\end{split}\]</div>
<p>For ease of programming we may introduce a <span class="math">\(g\)</span> function defined
over the whole of <span class="math">\(\Omega\)</span> such that <span class="math">\(g\)</span> takes on the
right values at <span class="math">\(y=0\)</span> and <span class="math">\(y=1\)</span>. One possible extension is</p>
<div class="math">
\[g(x,y) = -4y\thinspace .\]</div>
<p>The first task is to derive the variational problem. This time we
cannot omit the boundary term arising from the integration by parts,
because <span class="math">\(v\)</span> is only zero on <span class="math">\(\Gamma_D\)</span>. We have</p>
<div class="math">
\[ -\int_\Omega (\nabla^2 u)v \, \mathrm{d}x
= \int_\Omega\nabla u\cdot\nabla v \, \mathrm{d}x - \int_{\partial\Omega}{\partial u\over
\partial n}v \, \mathrm{d}s,\]</div>
<p>and since <span class="math">\(v=0\)</span> on <span class="math">\(\Gamma_D\)</span>,</p>
<div class="math">
\[- \int_{\partial\Omega}{\partial u\over
\partial n}v \, \mathrm{d}s
=
- \int_{\Gamma_N}{\partial u\over
\partial n}v \, \mathrm{d}s
= \int_{\Gamma_N}gv \, \mathrm{d}s,\]</div>
<p>by applying the boundary condition on <span class="math">\(\Gamma_N\)</span>.  The resulting
weak form reads</p>
<div class="math" id="equation-tut:poisson:2D:DN:weak">
<span class="eqno">(14)</span>\[     \int_{\Omega} \nabla u \cdot \nabla v \, \mathrm{d}x +
     \int_{\Gamma_N} gv \, \mathrm{d}s
     = \int_{\Omega} fv \, \mathrm{d}x\thinspace .\]</div>
<p>Expressing this equation in the standard notation <span class="math">\(a(u,v)=L(v)\)</span>
is straightforward with</p>
<div class="math">
\[\begin{split}a(u, v) &amp;= \int_{\Omega} \nabla u \cdot \nabla v \, \mathrm{d}x,
\\
L(v) &amp;= \int_{\Omega} fv \, \mathrm{d}x -
\int_{\Gamma_N} gv \, \mathrm{d}s\thinspace .\end{split}\]</div>
<p id="index-69">How does the Neumann condition impact the implementation?  Starting
with any of the previous files <tt class="docutils literal"><span class="pre">d*_p2D.py</span></tt>, say <tt class="docutils literal"><span class="pre">d4_p2D.py</span></tt>, we
realize that the statements remain almost the same.  Only two
adjustments are necessary:</p>
<blockquote>
<div><ul class="simple">
<li>The function describing the boundary where Dirichlet conditions
apply must be modified.</li>
<li>The new boundary term must be added to the expression in <tt class="docutils literal"><span class="pre">L</span></tt>.</li>
</ul>
</div></blockquote>
<p>Step 1 can be coded as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Dirichlet_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">on_boundary</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
<p>A more compact implementation reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Dirichlet_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>As pointed out already in the section <a class="reference internal" href="#tut-poisson1-impl"><em>Implementation (1)</em></a>,
testing for an exact match of real numbers is not good programming
practice so we introduce a tolerance in the test:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Dirichlet_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> \
           <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
</pre></div>
</div>
<p>The second adjustment of our program concerns the definition of <tt class="docutils literal"><span class="pre">L</span></tt>,
where we have to add a boundary integral and a definition of the
<span class="math">\(g\)</span> function to be integrated:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">g</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-4*x[1]&#39;</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">g</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">ds</span></tt> variable implies a boundary integral, while <tt class="docutils literal"><span class="pre">dx</span></tt> implies
an integral over the domain <span class="math">\(\Omega\)</span>.  No more modifications are
necessary.</p>
<p>The file <tt class="docutils literal"><span class="pre">dn1_p2D.py</span></tt> in the <tt class="docutils literal"><span class="pre">stationary/poisson</span></tt> directory
implements this problem. Running the program verifies the
implementation: <span class="math">\(u\)</span> equals the exact solution at all the nodes,
regardless of how many elements we use.</p>
</div>
<div class="section" id="multiple-dirichlet-conditions">
<span id="tut-poisson-multiple-dirichlet"></span><h2>Multiple Dirichlet Conditions<a class="headerlink" href="#multiple-dirichlet-conditions" title="Permalink to this headline">¶</a></h2>
<p>The PDE problem from the previous section applies a function
<span class="math">\(u_0(x,y)\)</span> for setting Dirichlet conditions at two parts of the
boundary.  Having a single function to set multiple Dirichlet
conditions is seldom possible. The more general case is to have
<span class="math">\(m\)</span> functions for setting Dirichlet conditions on <span class="math">\(m\)</span>
parts of the boundary.  The purpose of this section is to explain how
such multiple conditions are treated in FEniCS programs.</p>
<p id="index-70">Let us return to the case from the section <a class="reference internal" href="#tut-poisson1-dn"><em>Combining Dirichlet and Neumann Conditions</em></a> and
define two separate functions for the two Dirichlet conditions:</p>
<div class="math">
\[\begin{split}- \nabla^2 u &amp;= -6 \mbox{ in } \Omega, \\
u &amp;= u_L \mbox{ on } \Gamma_0, \\
u &amp;= u_R \mbox{ on } \Gamma_1, \\
- {\partial u\over\partial n} &amp;= g \mbox{ on } \Gamma_N \thinspace .\end{split}\]</div>
<p>Here, <span class="math">\(\Gamma_0\)</span> is the boundary <span class="math">\(x=0\)</span>, while
<span class="math">\(\Gamma_1\)</span> corresponds to the boundary <span class="math">\(x=1\)</span>.  We have
that <span class="math">\(u_L = 1 + 2y^2\)</span>, <span class="math">\(u_R = 2 + 2y^2\)</span>, and
<span class="math">\(g=-4y\)</span>.  For the left boundary <span class="math">\(\Gamma_0\)</span> we define the
usual triple of a function for the boundary value, a function for
defining the boundary of interest, and a <tt class="docutils literal"><span class="pre">DirichletBC</span></tt> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_L</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + 2*x[1]*x[1]&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">left_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_0</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_L</span><span class="p">,</span> <span class="n">left_boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>For the boundary <span class="math">\(x=1\)</span> we write a similar code snippet:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_R</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;2 + 2*x[1]*x[1]&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">right_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_1</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_R</span><span class="p">,</span> <span class="n">right_boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>The various essential conditions are then collected in a list and used
in the solution process:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Gamma_0</span><span class="p">,</span> <span class="n">Gamma_1</span><span class="p">]</span>
<span class="o">...</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
<span class="c"># or</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
<span class="n">solver</span>  <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>In other problems, where the <span class="math">\(u\)</span> values are constant at a part
of the boundary, we may use a simple <tt class="docutils literal"><span class="pre">Constant</span></tt> object instead of an
<tt class="docutils literal"><span class="pre">Expression</span></tt> object.</p>
<p>The file <tt class="docutils literal"><span class="pre">dn2_p2D.py</span></tt> contains a complete program which demonstrates
the constructions above.  An extended example with multiple Neumann
conditions would have been quite natural now, but this requires
marking various parts of the boundary using the mesh function concept
and is therefore left to the section <a class="reference internal" href="materials.html#tut-poisson-mat-neumann"><em>Multiple Neumann, Robin, and Dirichlet Condition</em></a>.</p>
</div>
<div class="section" id="a-linear-algebra-formulation">
<span id="tut-poisson1-linalg"></span><h2>A Linear Algebra Formulation<a class="headerlink" href="#a-linear-algebra-formulation" title="Permalink to this headline">¶</a></h2>
<p>Given <span class="math">\(a(u,v)=L(v)\)</span>, the discrete solution <span class="math">\(u\)</span> is computed
by inserting <span class="math">\(u=\sum_{j=1}^N U_j \phi_j\)</span> into <span class="math">\(a(u,v)\)</span> and
demanding <span class="math">\(a(u,v)=L(v)\)</span> to be fulfilled for <span class="math">\(N\)</span> test
functions <span class="math">\(\hat\phi_1,\ldots,\hat\phi_N\)</span>. This implies</p>
<div class="math">
\[\sum_{j=1}^N a(\phi_j,\hat\phi_i) U_j = L(\hat\phi_i),\quad i=1,\ldots,N,\]</div>
<p>which is nothing but a linear system,</p>
<div class="math">
\[AU = b,\]</div>
<p>where the entries in <span class="math">\(A\)</span> and <span class="math">\(b\)</span> are given by</p>
<div class="math">
\[\begin{split}A_{ij} &amp;= a(\phi_j, \hat{\phi}_i), \\
b_i &amp;= L(\hat\phi_i)\thinspace .\end{split}\]</div>
<span class="target" id="index-71"></span><span class="target" id="index-72"></span><p id="index-73">The examples so far have specified the left- and right-hand side of
the variational formulation and then asked FEniCS to assemble the
linear system and solve it.  An alternative to is explicitly call
functions for assembling the coefficient matrix <span class="math">\(A\)</span> and the
right-side vector <span class="math">\(b\)</span>, and then solve the linear system
<span class="math">\(AU=b\)</span> with respect to the <span class="math">\(U\)</span> vector.  Instead of
<tt class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">b)</span></tt> we now write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The variables <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">L</span></tt> are as before. That is, <tt class="docutils literal"><span class="pre">a</span></tt> refers to
the bilinear form involving a <tt class="docutils literal"><span class="pre">TrialFunction</span></tt> object (say <tt class="docutils literal"><span class="pre">u</span></tt>) and
a <tt class="docutils literal"><span class="pre">TestFunction</span></tt> object (<tt class="docutils literal"><span class="pre">v</span></tt>), and <tt class="docutils literal"><span class="pre">L</span></tt> involves a
<tt class="docutils literal"><span class="pre">TestFunction</span></tt> object (<tt class="docutils literal"><span class="pre">v</span></tt>). From <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">L</span></tt>, the
<tt class="docutils literal"><span class="pre">assemble</span></tt> function can compute <span class="math">\(A\)</span> and <span class="math">\(b\)</span>.</p>
<p>The matrix <span class="math">\(A\)</span> and vector <span class="math">\(b\)</span> are first assembled without
incorporating essential (Dirichlet) boundary conditions. Thereafter,
the call <tt class="docutils literal"><span class="pre">bc.apply(A,</span> <span class="pre">b)</span></tt> performs the necessary modifications of
the linear system such that <tt class="docutils literal"><span class="pre">u</span></tt> is guaranteed to equal the
prescribed boundary values.  When we have multiple Dirichlet
conditions stored in a list <tt class="docutils literal"><span class="pre">bcs</span></tt>, as explained in the section
<a class="reference internal" href="#tut-poisson-multiple-dirichlet"><em>Multiple Dirichlet Conditions</em></a>, we must apply each condition in
<tt class="docutils literal"><span class="pre">bcs</span></tt> to the system:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># bcs is a list of DirichletBC objects</span>
<span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
    <span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-74">There is an alternative function <tt class="docutils literal"><span class="pre">assemble_system</span></tt>, which can
assemble the system and take boundary conditions into account in one
call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">assemble_system</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">assemble_system</span></tt> function incorporates the boundary conditions
in the element matrices and vectors, prior to assembly.  The
conditions are also incorporated in a symmetric way to preserve
eventual symmetry of the coefficient matrix.
.. That is, for each degree of freedom</p>
<p>With <tt class="docutils literal"><span class="pre">bc.apply(A,</span> <span class="pre">b)</span></tt> the matrix <tt class="docutils literal"><span class="pre">A</span></tt> is modified in an unsymmetric
way.
.. : The row is zero&#8217;ed out</p>
<p>Note that the solution <tt class="docutils literal"><span class="pre">u</span></tt> is, as before, a <tt class="docutils literal"><span class="pre">Function</span></tt> object.
The degrees of freedom, <span class="math">\(U=A^{-1}b\)</span>, are filled into <cite>u</cite>&#8216;s
<tt class="docutils literal"><span class="pre">Vector</span></tt> object (<tt class="docutils literal"><span class="pre">u.vector()</span></tt>) by the <tt class="docutils literal"><span class="pre">solve</span></tt> function.</p>
<p>The object <tt class="docutils literal"><span class="pre">A</span></tt> is of type <tt class="docutils literal"><span class="pre">Matrix</span></tt>, while <tt class="docutils literal"><span class="pre">b</span></tt> and <tt class="docutils literal"><span class="pre">u.vector()</span></tt>
are of type <tt class="docutils literal"><span class="pre">Vector</span></tt>. We may convert the matrix and vector data to
<tt class="docutils literal"><span class="pre">numpy</span></tt> arrays by calling the <tt class="docutils literal"><span class="pre">array()</span></tt> method as shown before. If
you wonder how essential boundary conditions are incorporated in the
linear system, you can print out <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> before and after the
<tt class="docutils literal"><span class="pre">bc.apply(A,</span> <span class="pre">b)</span></tt> call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">num_cells</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">:</span>  <span class="c"># print for small meshes only</span>
    <span class="k">print</span> <span class="n">A</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">num_cells</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">A</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>With access to the elements in <tt class="docutils literal"><span class="pre">A</span></tt> through a <tt class="docutils literal"><span class="pre">numpy</span></tt> array we can
easily perform computations on this matrix, such as computing the
eigenvalues (using the <tt class="docutils literal"><span class="pre">eig</span></tt> function in <tt class="docutils literal"><span class="pre">numpy.linalg</span></tt>). We can
alternatively dump <tt class="docutils literal"><span class="pre">A.array()</span></tt> and <tt class="docutils literal"><span class="pre">b.array()</span></tt> to file in MATLAB
format and invoke MATLAB or Octave to analyze the linear system.
Dumping the arrays to MATLAB format is done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scipy.io</span>
<span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">savemat</span><span class="p">(</span><span class="s">&#39;Ab.mat&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="n">A</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="s">&#39;b&#39;</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">()})</span>
</pre></div>
</div>
<p>Writing <tt class="docutils literal"><span class="pre">load</span> <span class="pre">Ab.mat</span></tt> in MATLAB or Octave will then make the
variables <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> available for computations.</p>
<p id="index-75">Matrix processing in Python or MATLAB/Octave is only feasible for
small PDE problems since the <tt class="docutils literal"><span class="pre">numpy</span></tt> arrays or matrices in MATLAB
file format are dense matrices. DOLFIN also has an interface to the
eigensolver package SLEPc, which is a preferred tool for computing the
eigenvalues of large, sparse matrices of the type encountered in PDE
problems (see <tt class="docutils literal"><span class="pre">demo/la/eigenvalue</span></tt> in the DOLFIN source code tree
for a demo).</p>
<p id="index-76">A complete code where the linear system <span class="math">\(AU=b\)</span> is explicitly
assembled and solved is found in the file <tt class="docutils literal"><span class="pre">dn3_p2D.py</span></tt> in the
directory <tt class="docutils literal"><span class="pre">stationary/poisson</span></tt>. This code solves the same problem as
in <tt class="docutils literal"><span class="pre">dn2_p2D.py</span></tt> (the section <a class="reference internal" href="#tut-poisson-multiple-dirichlet"><em>Multiple Dirichlet Conditions</em></a>).
For small linear systems, the program writes out <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt>
before and after incorporation of essential boundary conditions and
illustrates the difference between <tt class="docutils literal"><span class="pre">assemble</span></tt> and
<tt class="docutils literal"><span class="pre">assemble_system</span></tt>.  The reader is encouraged to run the code for a
<span class="math">\(2\times 1\)</span> mesh (<tt class="docutils literal"><span class="pre">UnitSquare(2,</span> <span class="pre">1)</span></tt> and study the output of
<tt class="docutils literal"><span class="pre">A</span></tt>.</p>
<p>By default, <tt class="docutils literal"><span class="pre">solve(A,</span> <span class="pre">U,</span> <span class="pre">b)</span></tt> applies sparse LU decomposition as
solver. Specification of an iterative solver and preconditioner is
done through two optional arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s">&#39;cg&#39;</span><span class="p">,</span> <span class="s">&#39;ilu&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Appropriate names of solvers and preconditioners are found in the
section <a class="reference internal" href="misc.html#tut-app-solver-prec"><em>Linear Solvers and Preconditioners</em></a>.</p>
<span class="target" id="index-77"></span><p id="index-78">To control tolerances in the stopping criterion and the maximum number
of iterations, one can explicitly form a <tt class="docutils literal"><span class="pre">KrylovSolver</span></tt> object and
set items in its <tt class="docutils literal"><span class="pre">parameters</span></tt> attribute (see also the section
<a class="reference internal" href="#tut-poisson1-solver-problem"><em>Linear Variational Problem and Solver Objects</em></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solver</span> <span class="o">=</span> <span class="n">KrylovSolver</span><span class="p">(</span><span class="s">&#39;cg&#39;</span><span class="p">,</span> <span class="s">&#39;ilu&#39;</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-7</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-4</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">set_log_level</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The program <tt class="docutils literal"><span class="pre">dn4_p2D.py</span></tt> is a modification of <tt class="docutils literal"><span class="pre">dn3_p2D.py</span></tt>
illustrating this latter approach.</p>
<p id="index-79">The choice of start vector for the iterations in a linear solver is
often important. With the <tt class="docutils literal"><span class="pre">solver.solve(A,</span> <span class="pre">U,</span> <span class="pre">b)</span></tt> call the default
start vector is the zero vector. A start vector with random numbers in
the interval <span class="math">\([-100,100]\)</span> can be computed as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">n</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">.</span><span class="n">size</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">U</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;nonzero_initial_guess&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we must turn off the default behavior of setting the start
vector (&#8220;initial guess&#8221;) to zero.  A random start vector is included
in the <tt class="docutils literal"><span class="pre">dn4_p2D.py</span></tt> code.</p>
<p>Creating the linear system explicitly in a program can have some
advantages in more advanced problem settings. For example, <span class="math">\(A\)</span>
may be constant throughout a time-dependent simulation, so we can
avoid recalculating <span class="math">\(A\)</span> at every time level and save a
significant amount of simulation time. The sections
<a class="reference internal" href="timedep.html#tut-timedep-diffusion1-impl"><em>Implementation (2)</em></a> and
<a class="reference internal" href="timedep.html#tut-timedep-diffusion1-noassemble"><em>Avoiding Assembly</em></a> deal with this topic in
detail.</p>
</div>
<div class="section" id="parameterizing-the-number-of-space-dimensions">
<span id="tut-poisson-nd"></span><h2>Parameterizing the Number of Space Dimensions<a class="headerlink" href="#parameterizing-the-number-of-space-dimensions" title="Permalink to this headline">¶</a></h2>
<p id="index-80">FEniCS makes it is easy to write a unified simulation code that can
operate in 1D, 2D, and 3D. We will conveniently make use of this
feature in forthcoming examples.  As an appetizer, go back to the
introductory program <tt class="docutils literal"><span class="pre">d1_p2D.py</span></tt> in the <tt class="docutils literal"><span class="pre">stationary/poisson</span></tt>
directory and change the mesh construction from <tt class="docutils literal"><span class="pre">UnitSquare(6,</span> <span class="pre">4)</span></tt>
to <tt class="docutils literal"><span class="pre">UnitCube(6,</span> <span class="pre">4,</span> <span class="pre">5)</span></tt>. Now the domain is the unit cube partitioned
into <span class="math">\(6\times 4\times 5\)</span> boxes, and each box is divided into six
tetrahedra-shaped finite elements for computations.  Run the program
and observe that we can solve a 3D problem without any other
modifications (!). The visualization allows you to rotate the cube and
observe the function values as colors on the boundary.</p>
<p>The forthcoming material introduces some convenient
technicalities such that the same program can run in 1D, 2D, or 3D
without any modifications.
Consider the simple model problem</p>
<div class="math">
\[u''(x) = 2\hbox{ in }[0,1],\quad u(0)=0,\ u(1)=1,\]</div>
<p>with exact solution <span class="math">\(u(x)=x^2\)</span>. Our aim is to formulate and
solve this problem in a 2D and a 3D domain as well.  We may generalize
the domain <span class="math">\([0,1]\)</span> to a rectangle or box of any size in the
<span class="math">\(y\)</span> and <span class="math">\(z\)</span> directions and pose homogeneous Neumann
conditions <span class="math">\(\partial u/\partial n = 0\)</span> at all additional
boundaries <span class="math">\(y=\mbox{const}\)</span> and <span class="math">\(z=\mbox{const}\)</span> to ensure
that <span class="math">\(u\)</span> only varies with <span class="math">\(x\)</span>. For example, let us choose
a unit hypercube as domain: <span class="math">\(\Omega = [0,1]^d\)</span>, where <span class="math">\(d\)</span>
is the number of space dimensions. The generalized $d$-dimensional
Poisson problem then reads</p>
<div class="math" id="equation-tut:poisson1:ddim">
<span class="eqno">(15)</span>\[\begin{split}       \begin{array}{rcll}
         \nabla^2 u  &amp;=  2 &amp;\mbox{in } \Omega, \\
         u  &amp;=  0 &amp;\mbox{on } \Gamma_0,\\
         u  &amp;=  1 &amp;\mbox{on } \Gamma_1,\\
     {\partial u\over\partial n}  &amp;=  0 &amp;\mbox{on } \partial\Omega\backslash\left(
     \Gamma_0\cup\Gamma_1\right),
       \end{array}\end{split}\]</div>
<p>where <span class="math">\(\Gamma_0\)</span> is the side of the hypercube where <span class="math">\(x=0\)</span>, and
where <span class="math">\(\Gamma_1\)</span> is the side where <span class="math">\(x=1\)</span>.</p>
<p id="index-81">Implementing a PDE for any <span class="math">\(d\)</span> is no more complicated than
solving a problem with a specific number of dimensions.  The only
non-trivial part of the code is actually to define the mesh.  We use
the command line for the user-input to the program. The first argument
can be the degree of the polynomial in the finite element basis
functions.  Thereafter, we supply the cell divisions in the various
spatial directions. The number of command-line arguments will then
imply the number of space dimensions.  For example, writing <tt class="docutils literal"><span class="pre">3</span> <span class="pre">10</span> <span class="pre">3</span>
<span class="pre">4</span></tt> on the command line means that we want to approximate <span class="math">\(u\)</span> by
piecewise polynomials of degree 3, and that the domain is a
three-dimensional cube with <span class="math">\(10\times 3\times 4\)</span> divisions in
the <span class="math">\(x\)</span>, <span class="math">\(y\)</span>, and <span class="math">\(z\)</span> directions, respectively.
.. Each of the <span class="math">\(10\times 3\times 4 = 120\)</span> boxes will</p>
<p>The Python code can be quite compact:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">degree</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">divisions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">:]]</span>
<span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">divisions</span><span class="p">)</span>
<span class="n">domain_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">UnitInterval</span><span class="p">,</span> <span class="n">UnitSquare</span><span class="p">,</span> <span class="n">UnitCube</span><span class="p">]</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">domain_type</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="o">*</span><span class="n">divisions</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
</pre></div>
</div>
<p>First note that although <tt class="docutils literal"><span class="pre">sys.argv[2:]</span></tt> holds the divisions of the
mesh, all elements of the list <tt class="docutils literal"><span class="pre">sys.argv[2:]</span></tt> are string objects, so
we need to explicitly convert each element to an integer.  The
construction <tt class="docutils literal"><span class="pre">domain_type[d-1]</span></tt> will pick the right name of the
object used to define the domain and generate the mesh.  Moreover, the
argument <tt class="docutils literal"><span class="pre">*divisions</span></tt> sends all the component of the list
<tt class="docutils literal"><span class="pre">divisions</span></tt> as separate arguments. For example, in a 2D problem
where <tt class="docutils literal"><span class="pre">divisions</span></tt> has two elements, the statement</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">domain_type</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="o">*</span><span class="n">divisions</span><span class="p">)</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquare</span><span class="p">(</span><span class="n">divisions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">divisions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The next part of the program is to set up the boundary conditions.
Since the Neumann conditions have <span class="math">\(\partial u/\partial n=0\)</span> we
can omit the boundary integral from the weak form. We then only need
to take care of Dirichlet conditions at two sides:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
<span class="k">def</span> <span class="nf">Dirichlet_boundary0</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="k">def</span> <span class="nf">Dirichlet_boundary1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">bc0</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Dirichlet_boundary0</span><span class="p">)</span>
<span class="n">bc1</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Dirichlet_boundary1</span><span class="p">)</span>
<span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">bc0</span><span class="p">,</span> <span class="n">bc1</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that this code is independent of the number of space dimensions.
So are the statements defining and solving the variational problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
</pre></div>
</div>
<p>The complete code is found in the file <tt class="docutils literal"><span class="pre">paD.py</span></tt> (Poisson problem in
&#8220;anyD&#8221;).</p>
<p>If we want to parameterize the direction in which <span class="math">\(u\)</span> varies,
say by the space direction number <tt class="docutils literal"><span class="pre">e</span></tt>, we only need to replace
<tt class="docutils literal"><span class="pre">x[0]</span></tt> in the code by <tt class="docutils literal"><span class="pre">x[e]</span></tt>. The parameter <tt class="docutils literal"><span class="pre">e</span></tt> could be given
as a second command-line argument.  The reader is encouraged to
perform this modification.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="wrapper">
  <div class="footer">
    <div class="footer-nav">
      <div class="span-6">
	<h4>Usage documentation</h4>
	<ul>
	  <li><a href="/documentation/tutorial/">Tutorial</a></li>
	  <li><a href="/documentation/dolfin/dev/python/">Python API</a></li>
	  <li><a href="/documentation/dolfin/dev/cpp/">C++ API</a></li>
          <li><a href="/releases/">Release notes</a></li>
	</ul>
      </div>
      <div class="span-6">
	<h4>Developer resources</h4>
	<ul>
	  <li><a href="/buildbot/">Buildbot</a></li>
	  <li><a href="/benchbot/">Benchbot</a></li>
	  <li><a href="https://bitbucket.org/fenics-project/">FEniCS on Bitbucket</a></li>
	  <li><a href="/pub/">File archive</a></li>
	</ul>
      </div>
      <div class="span-6 last">
	<h4>Search this site</h4>
	<div id="searchbox">
	  <form class="search" action="/search.html" method="get">
	    <input type="text" name="q" size="18" />
	    <input type="submit" value="Go" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	</div>
      </div>
    </div>
    &copy; Copyright 2015, <a href="/">The FEniCS Project</a>. (<a href="/disclaimer.html">Disclaimer</a>)
  </div>
</div>

  </body>
</html>