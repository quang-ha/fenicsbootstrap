<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Handling Domains with Different Materials &mdash; FEniCS Project</title>
    
    <link rel="stylesheet" href="../../_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.9.9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="FEniCS Project" href="../../index.html" />
    <link rel="up" title="FEniCS tutorial (Python)" href="index.html" />
    <link rel="next" title="More Examples" href="more.html" />
    <link rel="prev" title="Creating More Complex Domains" href="prepro.html" />



<link rel="shortcut icon" href="../../_static/fenics.ico" />


<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-19595948-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </head>
  <body>
<div class="wrapper">
  <a href="/"><img src="../../_static/fenics_banner.png" width="900px" alt="FEniCS Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
	<li class="page_item"><a href="/about/" title="Find out more about the FEniCS project">About</a></li>
	<li class="page_item"><a href="/download/" title="Obtain the FEniCS project">Download</a></li>
	<li class="page_item"><a href="/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
	<li class="page_item"><a href="/applications/" title="Learn how others are using the FEniCS project">Applications</a></li>
	<li class="page_item"><a href="/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
	<li class="page_item"><a href="/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
	<li class="page_item"><a href="/support/" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="handling-domains-with-different-materials">
<h1>Handling Domains with Different Materials<a class="headerlink" href="#handling-domains-with-different-materials" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-0"></span><p id="index-1">Solving PDEs in domains made up of different materials is a frequently
encountered task. In FEniCS, these kind of problems are handled by
defining subdomains inside the domain. The subdomains may represent
the various materials. We can thereafter define material properties
through functions, known in FEniCS as <em>mesh functions</em>, that are
piecewise constant in each subdomain.  A simple example with two
materials (subdomains) in 2D will demonstrate the basic steps in the
process.
.. Later, a multi-material</p>
<div class="section" id="working-with-two-subdomains">
<span id="tut-possion-2d-2mat-problem"></span><h2>Working with Two Subdomains<a class="headerlink" href="#working-with-two-subdomains" title="Permalink to this headline">¶</a></h2>
<p>Suppose we want to solve</p>
<div class="math" id="equation-tut:poisson:2D:2mat:varcoeff2">
<span class="eqno">(1)</span>\[         \nabla\cdot \left\lbrack k(x,y)\nabla u(x,y)\right\rbrack = 0,\]</div>
<p>in a domain <span class="math">\(\Omega\)</span> consisting of two subdomains where
<span class="math">\(k\)</span> takes on a different value in each subdomain.  For
simplicity, yet without loss of generality, we choose for the current
implementation the domain <span class="math">\(\Omega = [0,1]\times [0,1]\)</span> and
divide it into two equal subdomains,</p>
<div class="math">
\[\Omega_0 = [0, 1]\times [0,1/2],\quad
\Omega_1 = [0, 1]\times (1/2,1]\thinspace .\]</div>
<p>We define <span class="math">\(k(x,y)=k_0\)</span> in <span class="math">\(\Omega_0\)</span> and
<span class="math">\(k(x,y)=k_1\)</span> in <span class="math">\(\Omega_1\)</span>, where <span class="math">\(k_0&gt;0\)</span> and
<span class="math">\(k_1&gt;0\)</span> are given constants.  As boundary conditions, we choose
<span class="math">\(u=0\)</span> at <span class="math">\(y=0\)</span>, <span class="math">\(u=1\)</span> at <span class="math">\(y=1\)</span>, and
<span class="math">\(\partial u/\partial n=0\)</span> at <span class="math">\(x=0\)</span> and <span class="math">\(x=1\)</span>.  One
can show that the exact solution is now given by</p>
<div class="math">
\[\begin{split}u(x, y) = \left\lbrace\begin{array}{ll}
{2yk_1\over k_0+k_1}, &amp; y \leq 1/2\\
{(2y-1)k_0 + k_1\over k_0+k_1}, &amp; y \geq 1/2
\end{array}\right.\end{split}\]</div>
<p>As long as the element boundaries coincide with the internal boundary
<span class="math">\(y=1/2\)</span>, this piecewise linear solution should be exactly
recovered by Lagrange elements of any degree. We use this property to
verify the implementation.</p>
<p>Physically, the present problem may correspond to heat conduction,
where the heat conduction in <span class="math">\(\Omega_1\)</span> is ten times more
efficient than in <span class="math">\(\Omega_0\)</span>. An alternative interpretation is
flow in porous media with two geological layers, where the layers&#8217;
ability to transport the fluid differs by a factor of 10.</p>
</div>
<div class="section" id="implementation-3">
<span id="tut-possion-2d-2mat-impl"></span><h2>Implementation (3)<a class="headerlink" href="#implementation-3" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-2"></span><p id="index-3">The new functionality in this subsection regards how to define the
subdomains <span class="math">\(\Omega_0\)</span> and <span class="math">\(\Omega_1\)</span>. For this purpose we
need to use subclasses of class <tt class="docutils literal"><span class="pre">SubDomain</span></tt>, not only plain
functions as we have used so far for specifying boundaries. Consider
the boundary function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>for defining the boundary <span class="math">\(x=0\)</span>. Instead of using such a
stand-alone function, we can create an instance (or object) of a
subclass of <tt class="docutils literal"><span class="pre">SubDomain</span></tt>, which implements the <tt class="docutils literal"><span class="pre">inside</span></tt> method as
an alternative to the <tt class="docutils literal"><span class="pre">boundary</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Boundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
        <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">boundary</span> <span class="o">=</span> <span class="n">Boundary</span><span class="p">()</span>
<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>A word about computer science terminology may be used here: The term
<em>instance</em> means a Python object of a particular type (such as
<tt class="docutils literal"><span class="pre">SubDomain</span></tt>, <tt class="docutils literal"><span class="pre">Function</span></tt> <tt class="docutils literal"><span class="pre">FunctionSpace</span></tt>, etc.).  Many use
<em>instance</em> and <em>object</em> as interchangeable terms. In other computer
programming languages one may also use the term <em>variable</em> for the
same thing.  We mostly use the well-known term <em>object</em> in this text.</p>
<p>A subclass of <tt class="docutils literal"><span class="pre">SubDomain</span></tt> with an <tt class="docutils literal"><span class="pre">inside</span></tt> method offers
functionality for marking parts of the domain or the boundary. Now we
need to define one class for the subdomain <span class="math">\(\Omega_0\)</span> where
<span class="math">\(y\leq 1/2\)</span> and another for the subdomain <span class="math">\(\Omega_1\)</span> where
<span class="math">\(y\geq 1/2\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Omega0</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.5</span> <span class="k">else</span> <span class="bp">False</span>

<span class="k">class</span> <span class="nc">Omega1</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.5</span> <span class="k">else</span> <span class="bp">False</span>
</pre></div>
</div>
<p>Notice the use of <tt class="docutils literal"><span class="pre">&lt;=</span></tt> and <tt class="docutils literal"><span class="pre">&gt;=</span></tt> in both tests. For a cell to
belong to, e.g., <span class="math">\(\Omega_1\)</span>, the <tt class="docutils literal"><span class="pre">inside</span></tt> method must return
<tt class="docutils literal"><span class="pre">True</span></tt> for all the vertices <tt class="docutils literal"><span class="pre">x</span></tt> of the cell. So to make the cells
at the internal boundary <span class="math">\(y=1/2\)</span> belong to <span class="math">\(\Omega_1\)</span>, we
need the test <tt class="docutils literal"><span class="pre">x[1]</span> <span class="pre">&gt;=</span> <span class="pre">0.5</span></tt>.</p>
<p>The next task is to use a <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> to mark all cells in
<span class="math">\(\Omega_0\)</span> with the subdomain number 0 and all cells in
<span class="math">\(\Omega_1\)</span> with the subdomain number 1.  Our convention is to
number subdomains as <span class="math">\(0,1,2,\ldots\)</span>.</p>
<p>A <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> is a discrete function that can be evaluated at a
set of so-called <em>mesh entities</em>. Examples of mesh entities are cells,
facets, and vertices. A <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> over cells is suitable to
represent subdomains (materials), while a <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> over facets
is used to represent pieces of external or internal boundaries.  Mesh
functions over vertices can be used to describe continuous fields.</p>
<p>Since we need to define subdomains of <span class="math">\(\Omega\)</span> in the present
example, we must make use of a <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> over cells. The
<tt class="docutils literal"><span class="pre">MeshFunction</span></tt> constructor is fed with three arguments: 1) the type
of value: <tt class="docutils literal"><span class="pre">'int'</span></tt> for integers, <tt class="docutils literal"><span class="pre">'uint'</span></tt> for positive (unsigned)
integers, <tt class="docutils literal"><span class="pre">'double'</span></tt> for real numbers, and <tt class="docutils literal"><span class="pre">'bool'</span></tt> for logical
values; 2) a <tt class="docutils literal"><span class="pre">Mesh</span></tt> object, and 3) the topological dimension of the
mesh entity in question: cells have topological dimension equal to the
number of space dimensions in the PDE problem, and facets have one
dimension lower.  Alternatively, the constructor can take just a
filename and initialize the <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> from data in a file.</p>
<p>We start with creating a <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> whose values are
non-negative integers (<tt class="docutils literal"><span class="pre">'uint'</span></tt>) for numbering the subdomains.  The
mesh entities of interest are the cells, which have dimension 2 in a
two-dimensional problem (1 in 1D, 3 in 3D). The appropriate code for
defining the <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> for two subdomains then reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">subdomains</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s">&#39;uint&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c"># Mark subdomains with numbers 0 and 1</span>
<span class="n">subdomain0</span> <span class="o">=</span> <span class="n">Omega0</span><span class="p">()</span>
<span class="n">subdomain0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">subdomains</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">subdomain1</span> <span class="o">=</span> <span class="n">Omega1</span><span class="p">()</span>
<span class="n">subdomain1</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">subdomains</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Calling <tt class="docutils literal"><span class="pre">subdomains.array()</span></tt> returns a <tt class="docutils literal"><span class="pre">numpy</span></tt> array of the
subdomain values. That is, <tt class="docutils literal"><span class="pre">subdomain.array()[i]</span></tt> is the subdomain
value of cell number <tt class="docutils literal"><span class="pre">i</span></tt>. This array is used to look up the
subdomain or material number of a specific element.</p>
<p>We need a function <tt class="docutils literal"><span class="pre">k</span></tt> that is constant in each subdomain
<span class="math">\(\Omega_0\)</span> and <span class="math">\(\Omega_1\)</span>. Since we want <tt class="docutils literal"><span class="pre">k</span></tt> to be a
finite element function, it is natural to choose a space of functions
that are constant over each element.  The family of discontinuous
Galerkin methods, in FEniCS denoted by <tt class="docutils literal"><span class="pre">'DG'</span></tt>, is suitable for this
purpose. Since we want functions that are piecewise constant, the
value of the degree parameter is zero:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;DG&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">k</span>  <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V0</span><span class="p">)</span>
</pre></div>
</div>
<p>To fill <tt class="docutils literal"><span class="pre">k</span></tt> with the right values in each element, we loop over all
cells (i.e., indices in <tt class="docutils literal"><span class="pre">subdomain.array()</span></tt>), extract the
corresponding subdomain number of a cell, and assign the corresponding
<span class="math">\(k\)</span> value to the <tt class="docutils literal"><span class="pre">k.vector()</span></tt> array:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">k_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>  <span class="c"># values of k in the two subdomains</span>
<span class="k">for</span> <span class="n">cell_no</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">())):</span>
    <span class="n">subdomain_no</span> <span class="o">=</span> <span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">()[</span><span class="n">cell_no</span><span class="p">]</span>
    <span class="n">k</span><span class="o">.</span><span class="n">vector</span><span class="p">()[</span><span class="n">cell_no</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_values</span><span class="p">[</span><span class="n">subdomain_no</span><span class="p">]</span>
</pre></div>
</div>
<p>Long loops in Python are known to be slow, so for large meshes it is
preferable to avoid such loops and instead use <em>vectorized code</em>.
Normally this implies that the loop must be replaced by calls to
functions from the <tt class="docutils literal"><span class="pre">numpy</span></tt> library that operate on complete arrays
(in efficient C code). The functionality we want in the present case
is to compute an array of the same size as <tt class="docutils literal"><span class="pre">subdomain.array()</span></tt>, but
where the value <tt class="docutils literal"><span class="pre">i</span></tt> of an entry in <tt class="docutils literal"><span class="pre">subdomain.array()</span></tt> is replaced
by <tt class="docutils literal"><span class="pre">k_values[i]</span></tt>.  Such an operation is carried out by the <tt class="docutils literal"><span class="pre">numpy</span></tt>
function <tt class="docutils literal"><span class="pre">choose</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">help</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">k</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">help</span><span class="p">,</span> <span class="n">k_values</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">help</span></tt> array is required since <tt class="docutils literal"><span class="pre">choose</span></tt> cannot work with
<tt class="docutils literal"><span class="pre">subdomain.array()</span></tt> because this array has elements of type
<tt class="docutils literal"><span class="pre">uint32</span></tt>. We must therefore transform this array to an array
<tt class="docutils literal"><span class="pre">help</span></tt> with standard <tt class="docutils literal"><span class="pre">int32</span></tt> integers.</p>
<p>Having the <tt class="docutils literal"><span class="pre">k</span></tt> function ready for finite element computations, we
can proceed in the normal manner with defining essential boundary
conditions, as in the section <a class="reference internal" href="fundamentals.html#tut-poisson-multiple-dirichlet"><em>Multiple Dirichlet Conditions</em></a>,
and the <span class="math">\(a(u,v)\)</span> and <span class="math">\(L(v)\)</span> forms, as in the section
<a class="reference internal" href="fundamentals.html#tut-possion-2d-varcoeff"><em>A Variable-Coefficient Poisson Problem</em></a>.  All the details can be found in the
file <tt class="docutils literal"><span class="pre">mat2_p2D.py</span></tt>.</p>
</div>
<div class="section" id="multiple-neumann-robin-and-dirichlet-condition">
<span id="tut-poisson-mat-neumann"></span><h2>Multiple Neumann, Robin, and Dirichlet Condition<a class="headerlink" href="#multiple-neumann-robin-and-dirichlet-condition" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-4"></span><span class="target" id="index-5"></span><span class="target" id="index-6"></span><p id="index-7">Let us go back to the model problem from the section
<a class="reference internal" href="fundamentals.html#tut-poisson-multiple-dirichlet"><em>Multiple Dirichlet Conditions</em></a> where we had both Dirichlet and
Neumann conditions.  The term <tt class="docutils literal"><span class="pre">v*g*ds</span></tt> in the expression for <tt class="docutils literal"><span class="pre">L</span></tt>
implies a boundary integral over the complete boundary, or in FEniCS
terms, an integral over all exterior facets.  However, the
contributions from the parts of the boundary where we have Dirichlet
conditions are erased when the linear system is modified by the
Dirichlet conditions.  We would like, from an efficiency point of
view, to integrate <tt class="docutils literal"><span class="pre">v*g*ds</span></tt> only over the parts of the boundary
where we actually have Neumann conditions.  And more importantly, in
other problems one may have different Neumann conditions or other
conditions like the Robin type condition.  With the mesh function
concept we can mark different parts of the boundary and integrate over
specific parts.  The same concept can also be used to treat multiple
Dirichlet conditions.  The forthcoming text illustrates how this is
done.</p>
<p>Essentially, we still stick to the model problem from the section
<a class="reference internal" href="fundamentals.html#tut-poisson-multiple-dirichlet"><em>Multiple Dirichlet Conditions</em></a>, but replace the Neumann
condition at <span class="math">\(y=0\)</span> by a <em>Robin condition</em>:</p>
<div class="math">
\[-{\partial u\over\partial n} = p(u-q),\]</div>
<p>where <span class="math">\(p\)</span> and <span class="math">\(q\)</span> are specified functions.  The Robin
condition is most often used to model heat transfer to the
surroundings and arise naturally from Newton&#8217;s cooling law.</p>
<p>Since we have prescribed a simple solution in our model problem,
<span class="math">\(u=1+x^2+2y^2\)</span>, we adjust <span class="math">\(p\)</span> and <span class="math">\(q\)</span> such that the
condition holds at <span class="math">\(y=0\)</span>. This implies that <span class="math">\(q=1+x^2+2y^2\)</span>
and <span class="math">\(p\)</span> can be arbitrary (the normal derivative at <span class="math">\(y=0\)</span>:
<span class="math">\(\partial u/\partial n = -\partial u/\partial y = -4y=0\)</span>).</p>
<p>Now we have four parts of the boundary: <span class="math">\(\Gamma_N\)</span> which
corresponds to the upper side <span class="math">\(y=1\)</span>, <span class="math">\(\Gamma_R\)</span> which
corresponds to the lower part <span class="math">\(y=0\)</span>, <span class="math">\(\Gamma_0\)</span> which
corresponds to the left part <span class="math">\(x=0\)</span>, and <span class="math">\(\Gamma_1\)</span> which
corresponds to the right part <span class="math">\(x=1\)</span>. The complete boundary-value
problem reads</p>
<div class="math">
\[\begin{split}- \nabla^2 u &amp;= -6 \mbox{ in } \Omega, \\
u &amp;= u_L \mbox{ on } \Gamma_0, \\
u &amp;= u_R \mbox{ on } \Gamma_1, \\
- {\partial u\over\partial n} &amp;= p(u-q) \mbox{ on } \Gamma_R,
\\
- {\partial u\over\partial n} &amp;= g \mbox{ on } \Gamma_N\thinspace .\end{split}\]</div>
<p>The involved prescribed functions are <span class="math">\(u_L= 1 + 2y^2\)</span>,
<span class="math">\(u_R = 2 + 2y^2\)</span>, <span class="math">\(q=1+x^2+2y^2\)</span>, <span class="math">\(p\)</span> is arbitrary,
and <span class="math">\(g=-4y\)</span>.</p>
<p>Integration by parts of <span class="math">\(-\int_\Omega v\nabla^2 u \,
\mathrm{d}x\)</span> becomes as usual</p>
<div class="math">
\[ -\int_\Omega v\nabla^2 u \, \mathrm{d}x
= \int_\Omega\nabla u\cdot \nabla v \, \mathrm{d}x - \int_{\partial\Omega}{\partial u\over
\partial n}v \, \mathrm{d}s\thinspace .\]</div>
<p>The boundary integral vanishes on <span class="math">\(\Gamma_0\cup\Gamma_1\)</span>, and we
split the parts over <span class="math">\(\Gamma_N\)</span> and <span class="math">\(\Gamma_R\)</span> since we
have different conditions at those parts:</p>
<div class="math">
\[- \int_{\partial\Omega}v{\partial u\over\partial n} \, \mathrm{d}s
=
-\int_{\Gamma_N}v{\partial u\over\partial n} \, \mathrm{d}s -
\int_{\Gamma_R}v{\partial u\over\partial n} \, \mathrm{d}s
= \int_{\Gamma_N}vg \, \mathrm{d}s +
\int_{\Gamma_R}vp(u-q) \, \mathrm{d}s\thinspace .\]</div>
<p>The weak form then becomes</p>
<div class="math">
\[\int_{\Omega} \nabla u\cdot \nabla v \, \mathrm{d}x +
\int_{\Gamma_N} gv \, \mathrm{d}s + \int_{\Gamma_R}p(u-q)v \, \mathrm{d}s
= \int_{\Omega} fv \, \mathrm{d}x,\]</div>
<p>We want to write this weak form in the standard notation
<span class="math">\(a(u,v)=L(v)\)</span>, which requires that we identify all integrals
with <em>both</em> <span class="math">\(u\)</span> and <span class="math">\(v\)</span>, and collect these in
<span class="math">\(a(u,v)\)</span>, while the remaining integrals with <span class="math">\(v\)</span> and not
<span class="math">\(u\)</span> go into <span class="math">\(L(v)\)</span>.  The integral from the Robin condition
must of this reason be split in two parts:</p>
<div class="math">
\[\int_{\Gamma_R}p(u-q)v \, \mathrm{d}s
= \int_{\Gamma_R}puv \, \mathrm{d}s - \int_{\Gamma_R}pqv \, \mathrm{d}s\thinspace .\]</div>
<p>We then have</p>
<div class="math">
\[\begin{split}a(u, v) &amp;= \int_{\Omega} \nabla u\cdot \nabla v \, \mathrm{d}x
+ \int_{\Gamma_R}puv \, \mathrm{d}s,
\\
L(v) &amp;= \int_{\Omega} fv \, \mathrm{d}x -
\int_{\Gamma_N} g v \, \mathrm{d}s + \int_{\Gamma_R}pqv \, \mathrm{d}s\thinspace .\end{split}\]</div>
<p id="index-8">A natural starting point for implementation is the <tt class="docutils literal"><span class="pre">dn2_p2D.py</span></tt>
program in the directory <tt class="docutils literal"><span class="pre">stationary/poisson</span></tt>. The new aspects are</p>
<blockquote>
<div><ul class="simple">
<li>definition of a mesh function over the boundary,</li>
<li>marking each side as a subdomain, using the mesh function,</li>
<li>splitting a boundary integral into parts.</li>
</ul>
</div></blockquote>
<p>Task 1 makes use of the <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> object, but contrary to the
section <a class="reference internal" href="#tut-possion-2d-2mat-impl"><em>Implementation (3)</em></a>, this is not a function over
cells, but a function over cell facets. The topological dimension of
cell facets is one lower than the cell interiors, so in a
two-dimensional problem the dimension becomes 1. In general, the facet
dimension is given as <tt class="docutils literal"><span class="pre">mesh.topology().dim()-1</span></tt>, which we use in the
code for ease of direct reuse in other problems.  The construction of
a <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> object to mark boundary parts now reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">boundary_parts</span> <span class="o">=</span> \
  <span class="n">MeshFunction</span><span class="p">(</span><span class="s">&quot;uint&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>As in the section <a class="reference internal" href="#tut-possion-2d-2mat-impl"><em>Implementation (3)</em></a> we use a subclass of
<tt class="docutils literal"><span class="pre">SubDomain</span></tt> to identify the various parts of the mesh
function. Problems with domains of more complicated geometries may set
the mesh function for marking boundaries as part of the mesh
generation.  In our case, the <span class="math">\(y=0\)</span> boundary can be marked by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">LowerRobinBoundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
        <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_R</span> <span class="o">=</span> <span class="n">LowerRobinBoundary</span><span class="p">()</span>
<span class="n">Gamma_R</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>The code for the <span class="math">\(y=1\)</span> boundary is similar and is seen in
<tt class="docutils literal"><span class="pre">dnr_p2D.py</span></tt>.</p>
<p>The Dirichlet boundaries are marked similarly, using subdomain number 2 for <span class="math">\(\Gamma_0\)</span> and 3 for <span class="math">\(\Gamma_1\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">LeftBoundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
        <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_0</span> <span class="o">=</span> <span class="n">LeftBoundary</span><span class="p">()</span>
<span class="n">Gamma_0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">RightBoundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
        <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_1</span> <span class="o">=</span> <span class="n">RightBoundary</span><span class="p">()</span>
<span class="n">Gamma_1</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Specifying the <tt class="docutils literal"><span class="pre">DirichletBC</span></tt> objects may now make use of the mesh
function (instead of a <tt class="docutils literal"><span class="pre">SubDomain</span></tt> subclass object) and an indicator
for which subdomain each condition should be applied to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_L</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
<span class="n">u_R</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;2 + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
<span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_L</span><span class="p">,</span> <span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
       <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_R</span><span class="p">,</span> <span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p>Some functions need to be defined before we can go on with the <tt class="docutils literal"><span class="pre">a</span></tt>
and <tt class="docutils literal"><span class="pre">L</span></tt> of the variational problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">g</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-4*x[1]&#39;</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>  <span class="c"># arbitrary function can go here</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>
</pre></div>
</div>
<p>The new aspect of the variational problem is the two distinct boundary
integrals.  Having a mesh function over exterior cell facets (our
<tt class="docutils literal"><span class="pre">boundary_parts</span></tt> object), where subdomains (boundary parts) are
numbered as <span class="math">\(0,1,2,\ldots\)</span>, the special symbol <tt class="docutils literal"><span class="pre">ds(0)</span></tt> implies
integration over subdomain (part) 0, <tt class="docutils literal"><span class="pre">ds(1)</span></tt> denotes integration
over subdomain (part) 1, and so on.  The idea of multiple <cite>ds</cite>-type
objects generalizes to volume integrals too: <tt class="docutils literal"><span class="pre">dx(0)</span></tt>, <tt class="docutils literal"><span class="pre">dx(1)</span></tt>,
etc., are used to integrate over subdomain 0, 1, etc., inside
<span class="math">\(\Omega\)</span>.</p>
<p>The variational problem can be defined as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">g</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>For the <tt class="docutils literal"><span class="pre">ds(0)</span></tt> and <tt class="docutils literal"><span class="pre">ds(1)</span></tt> symbols to work we must obviously
connect them (or <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">L</span></tt>) to the mesh function marking parts
of the boundary. This is done by a certain keyword argument to the
<tt class="docutils literal"><span class="pre">assemble</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">exterior_facet_domains</span><span class="o">=</span><span class="n">boundary_parts</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">exterior_facet_domains</span><span class="o">=</span><span class="n">boundary_parts</span><span class="p">)</span>
</pre></div>
</div>
<p>Then essential boundary conditions are enforced, and the system can be
solved in the usual way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
    <span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The complete code is in the <tt class="docutils literal"><span class="pre">dnr_p2D.py</span></tt> file in the
<tt class="docutils literal"><span class="pre">stationary/poisson</span></tt> directory.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="wrapper">
  <div class="footer">
    <div class="footer-nav">
      <div class="span-6">
	<h4>Usage documentation</h4>
	<ul>
	  <li><a href="/documentation/tutorial/">Tutorial</a></li>
	  <li><a href="/documentation/dolfin/dev/python/">Python API</a></li>
	  <li><a href="/documentation/dolfin/dev/cpp/">C++ API</a></li>
          <li><a href="/releases/">Release notes</a></li>
	</ul>
      </div>
      <div class="span-6">
	<h4>Developer resources</h4>
	<ul>
	  <li><a href="/buildbot/">Buildbot</a></li>
	  <li><a href="/benchbot/">Benchbot</a></li>
	  <li><a href="https://bitbucket.org/fenics-project/">FEniCS on Bitbucket</a></li>
	  <li><a href="/pub/">File archive</a></li>
	</ul>
      </div>
      <div class="span-6 last">
	<h4>Search this site</h4>
	<div id="searchbox">
	  <form class="search" action="/search.html" method="get">
	    <input type="text" name="q" size="18" />
	    <input type="submit" value="Go" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	</div>
      </div>
    </div>
    &copy; Copyright 2015, <a href="/">The FEniCS Project</a>. (<a href="/disclaimer.html">Disclaimer</a>)
  </div>
</div>

  </body>
</html>